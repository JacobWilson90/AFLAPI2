#'Match Chains
#'
#'Get a list of possession chains for a match.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of possession chains for a match, with one row per chain. NULL if the match is yet to start.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{squad.name} The name of the squad in possession during the chain.
#'    \item \code{squad.code} A short code to represent the squad in possession during the chain.
#'    \item \code{period} The period of the possession chain.
#'    \item \code{start.id} The transaction ID of the start of the chain.
#'    \item \code{start.secs} The elapsed time within the period at the start of the chain.
#'    \item \code{start.name} The starting state of the chain.
#'    \item \code{start.code} A short code representing the starting state of the chain.
#'    \item \code{start.type} The start type of the chain.
#'    \item \code{start.type.code} A short code representing the starting type of the chain.
#'    \item \code{start.zone} The starting zone of the chain, relative to the squad in possession.
#'    \item \code{start.zone.physical} The starting zone of the chain, relative to the physical ground.
#'    \item \code{launch.id} A unique numerical identifier of the player who launched the chain.
#'    \item \code{launch.name} The full name of the player who launched the chain.
#'    \item \code{launch.display} The display name of the player who launched the chain, represented as first initial and surname.
#'    \item \code{end.id} The transaction ID of the end of the chain.
#'    \item \code{end.secs} The elapsed time within the period at the end of the chain.
#'    \item \code{end.name} The final state of the chain.
#'    \item \code{end.code} A short code representing the final state of the chain.
#'    \item \code{end.type} The end type of the chain.
#'    \item \code{end.type.code} A short code representing the end type of the chain.
#'    \item \code{end.zone} The final zone of the chain, relative to the squad in possession.
#'    \item \code{end.zone.physical} The final zone of the chain, relative to the physical ground.
#'    \item \code{score.id} The transaction ID of the scoring shot, if a score was generated during the chain.
#'    \item \code{score.result} The result scoring shot, if a score was generated during the chain.
#'    \item \code{score.points} The points generated by the scoring shot, if a score was generated during the chain.
#'    \item \code{score.player.id} A unique numerical identifier of the player who scored within the chain.
#'    \item \code{score.player.name} The full name of the player who scored within the chain.
#'    \item \code{score.player.display} The display name of the player who scored within the chain, represented as first initial and surname.
#'    \item \code{turnover.id} A unique numerical identifier of the player who turned the ball over at the end of the chain.
#'    \item \code{turnover.name} The full name of the player who turned the ball overa at the end of the chain.
#'    \item \code{turnover.display} The display name of the player who turned the ball overa at the end of the chain, represented as first initial and surname.
#'    \item \code{turnover.type} The type of turnover that was commited. Kick, handball or non-disposal.
#'    \item \code{turnover.state} The match state of the turnover that was commited. Clearing stoppage or General Play.
#'    \item \code{turnover.creation} The creation method of the turnover that was commited. Forced/Unforced Giveaway or Opposition Takeaway.
#'    \item \code{clearance.id} The transaction ID of the clearance that was won within the chain.
#'    \item \code{inside50.id} The transaction ID of the first inside 50 that was generated by the squad in possession within the chain.
#'    \item \code{rebound50.id} The transaction ID of the first rebound 50 that was generated by the squad in possession within the chain.
#'    \item \code{next.id} The transaction ID of the start of the next possession chain.
#'    \item \code{prevoius.id} The transaction ID of the start of the previous possession chain.
#'    \item \code{chain.metres.gained} Metres gained by a team within possession chains, combining measures towards attacking goal and away from defensive goal.
#'    \item \code{chain.metres.gained.reply} Chain Metres conceded to the opposition in the next chain after a turnover.
#'    \item \code{chain.metres.gained.net} Net Metres gained in a chain of possession after subtracting opposition Metres gained after a turnover. Equal to Chain Metres minus Chain Metres Reply.
#'}
#'@examples
#'getChains(216085122)
#'@export
getChains <- function(matchId,...){
  temp <- cdAPI(paste('matches',matchId,'chains',sep='/'),...)
  
  if(is.null(temp)) return(NULL)
  
  if(!'chains.end.score.matchTrxId'%in%names(temp)) temp <- temp %>% 
      mutate(chains.end.score.matchTrxId=NA_integer_,
             chains.end.score.result.code=NA,
             chains.end.score.result.points=NA_integer_,
             chains.end.score.player.id=NA_integer_,
             chains.end.score.player.fullname=NA,
             chains.end.turnover.player.displayName.display=NA)
  
  if(!'chains.end.turnover.type'%in%names(temp)) temp <- temp %>%
      mutate(chains.end.turnover.player.id=NA_integer_,
             chains.end.turnover.player.fullname=NA,
             chains.end.turnover.player.displayName=NA,
             chains.end.turnover.type=NA,
             chains.end.turnover.state=NA,
             chains.end.turnover.creation=NA)
  
  if(!'chains.keyTransactions.clearance'%in%names(temp)) temp <- temp %>% mutate(chains.keyTransactions.clearance = NA_integer_)
  if(!'chains.keyTransactions.inside50'%in%names(temp))  temp <- temp %>% mutate(chains.keyTransactions.inside50  = NA_integer_)
  if(!'chains.keyTransactions.nextChain'%in%names(temp)) temp <- temp %>% mutate(chains.keyTransactions.nextChain = NA_integer_)
  if(!'chains.keyTransactions.rebound50'%in%names(temp)) temp <- temp %>% mutate(chains.keyTransactions.rebound50 = NA_integer_)
  if(!'chains.keyTransactions.prevChain'%in%names(temp)) temp <- temp %>% mutate(chains.keyTransactions.prevChain = NA_integer_)
  if(!'chains.keyTransactions.stoppage'%in%names(temp))  temp <- temp %>% mutate(chains.keyTransactions.stoppage  = NA_integer_)
  
  temp <- temp %>%
    select(match.id='matchId',
           squad.id='chains.squad.id',
           squad.name='chains.squad.name',
           squad.code='chains.squad.code',
           period='chains.period',
           start.id='chains.start.matchTrxId',
           start.secs='chains.start.periodSecs',
           start.name='chains.start.stateName',
           start.code='chains.start.stateCode',
           start.type='chains.start.stateType',
           start.type.code = "chains.start.stateTypeCode" ,
           start.zone='chains.start.zone',
           start.zone.physical='chains.start.zonePhysical',
           start.x="chains.start.x",
           start.y="chains.start.y",
           launch.id='chains.start.launchPlayer.id',
           launch.name='chains.start.launchPlayer.fullname',
           launch.display='chains.start.launchPlayer.displayName',
           end.id='chains.end.matchTrxId',
           end.secs='chains.end.periodSecs',
           end.name='chains.end.stateName',
           end.code='chains.end.stateCode',
           end.type='chains.end.stateType',
           end.type.code='chains.end.stateTypeCode',
           end.zone='chains.end.zone',
           end.zone.physical='chains.end.zonePhysical',
           end.x="chains.end.x",
           end.y="chains.end.y",
           score.id='chains.end.score.matchTrxId',
           score.result='chains.end.score.result.code',
           score.result.name='chains.end.score.result.name',
           score.points='chains.end.score.result.points',
           score.player.id='chains.end.score.player.id',
           score.player.name='chains.end.score.player.fullname',
           score.player.display='chains.end.score.player.displayName',
           turnover.player.id='chains.end.turnover.player.id',
           turnover.player.name='chains.end.turnover.player.fullname',
           turnover.player.display='chains.end.turnover.player.displayName',
           turnover.type='chains.end.turnover.type',
           turnover.state='chains.end.turnover.state',
           turnover.creation='chains.end.turnover.creation',
           clearance.id='chains.keyTransactions.clearance',
           inside50.id='chains.keyTransactions.inside50',
           rebound50.id='chains.keyTransactions.rebound50',
           stoppage.id='chains.keyTransactions.stoppage',
           next.id='chains.keyTransactions.nextChain',
           previous.id='chains.keyTransactions.prevChain' , 
           chain.metres.gained="chains.metrics.chainMetres" , 
           chain.metres.gained.reply="chains.metrics.chainMetresReply" , 
           chain.metres.gained.net="chains.metrics.chainMetresNet" 
    ) 
  
  return(temp)
}

#'Match Rotations
#'
#'Get a list of rotations for a match.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of rotations for the match, with one row per interchange move.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{id} The transaction ID of the interchange move, used for ordering chronologically.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{period} The period of the interchange move.
#'    \item \code{secs} The elapsed time within the period of the interchange move.
#'    \item \code{off.id} A unique numerical identifier of the player coming off the ground.
#'    \item \code{off.name} The full name of the player coming off the ground.
#'    \item \code{off.display} The display name of the player coming off the ground, represented as first initial and surname.
#'    \item \code{off.reason} The reason for the interchange move.
#'    \item \code{off.code} A short text description of the reason for the interchange move.
#'    \item \code{on.id} A unique numerical identifier of the player coming on the ground. Empty for start-of-match initialisation of the interchange bench.
#'    \item \code{on.name} The full name of the player coming on the ground. Empty for start-of-match initialisation of the interchange bench.
#'    \item \code{on.display} The display name of the player coming on the ground, represented as first initial and surname. Empty for start-of-match initialisation of the interchange bench.
#'}
#'@examples
#'getRotations(216085122)
#'@export
getRotations <- function(matchId,...){
  temp <- cdAPI(paste('matches',matchId,'rotations',sep='/'),df=FALSE,...) 
  r <- temp %>% content()
  rotations <- r$rotations
  if(length(rotations)==0) return(NULL)
  trot <- do.call(bind_rows,lapply(rotations,unlist))
  if(!'on.personId'%in%names(trot)) trot <- trot %>% mutate(on.personId=NA,on.fullname=NA,on.displayName=NA)
  trot %>%
    mutate(match.id=matchId) %>%
    select(match.id,
           id='matchTrxId',
           squad.id,squad.name,squad.code,
           period,secs='periodSecs',
           off.id='off.personId',
           off.name='off.fullname',
           off.display='off.displayName',
           off.reason='off.reason',
           off.code='off.reasonCode',
           on.id='on.personId',
           on.name='on.fullname',
           on.display='on.displayName')
}

#'Match Bench
#'
#'Get the current bench status of all players in a match.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of all players for the match and their current bench status.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{id} A unique numerical identifier of the player.
#'    \item \code{name} The full name of the player.
#'    \item \code{display} The display name of the player, represented as first initial and surname.
#'    \item \code{status} The player's current status.
#'    \item \code{elapsed} Seconds elapsed within the current period since the player's last interchange move.
#'}
#'@examples
#'getBench(216085122)
#'@export
getBench <- function(matchId,...){
  r <- cdAPI(paste('matches',matchId,'rotations',sep='/'),df=FALSE,...) %>%
    content()
  if(length(r$home$players)==0) return(NULL)
  home <- data.frame(with(r$home,data.frame(squadCode,squadId,squadName,stringsAsFactors = FALSE)),data.frame(do.call(bind_rows,lapply(r$home$players,unlist))))
  away <- data.frame(with(r$away,data.frame(squadCode,squadId,squadName,stringsAsFactors = FALSE)),data.frame(do.call(bind_rows,lapply(r$away$players,unlist))))
  temp <- bind_rows(home,away)
  if(!'currentStint.status'%in%names(temp)) temp <- temp %>% mutate(currentStint.status=NA)
  if(!'currentStint.elapsedSecs'%in%names(temp)) temp <- temp %>% mutate(currentStint.status=NA)
  temp %>%
    mutate(match.id=matchId) %>%
    select(match.id,
           squad.id='squadId',
           squad.name='squadName',
           squad.code='squadCode',
           id='personId',
           name='fullname',
           display='displayName',
           status='currentStint.status',
           elapsed='currentStint.elapsedSecs')
}

#'Match Shots
#'
#'Get a list of shots at goal for a match. Also includes rushed behinds.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of shots at goal for a match, with one row per shot.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{id} The transaction ID of the shot, used for ordering chronologically.
#'    \item \code{period} The period of the shot.
#'    \item \code{secs} The elapsed time within the period of the shot.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{player.id} A unique numerical identifier of the player taking the shot.
#'    \item \code{player.name} The full name of the player taking the shot.
#'    \item \code{player.display} The display name of the player taking the shot, represented as first initial and surname.
#'    \item \code{origin} How the player was able to generate a shot at goal.
#'    \item \code{type} The type of shot attempted.
#'    \item \code{angle} A text description of the angle of the shot.
#'    \item \code{distance} A text description of the distance of the shot.
#'    \item \code{x} Distance in metres from the centre of the ground (measuring goal to goal), with the goals being at positive (venue_length / 2).
#'    \item \code{y} Distance in metres from the centre of the ground (measuring boundary to boundary), with the goals being at zero and the boundary line at halfway being at (venue_widht / 2). Positive y is bottom of screen when running to the right.
#'    \item \code{x.std} The x coordinate of the shot transformed to a standard ground dimension (160x141).
#'    \item \code{y.std} The y coordinate of the shot transformed to a standard ground dimension (160x141).
#'    \item \code{result} The result of the shot. G / B / R / M.
#'    \item \code{points} The number of points obtained from the shot.
#'}
#'@examples
#'getShots(216085122)
#'@export
getShots <- function(matchId,...){
  temp <- cdAPI(paste('matches',matchId,'shots',sep='/'),...)
  if(is.null(temp)) return(NULL)
  if(!'shots.result.pointsExpected'%in%names(temp)) temp <- temp %>% mutate(shots.result.pointsExpected=NA,
                                                                            shots.result.accuracyExpected=NA)
  temp %>%
    select(match.id='matchId',
           id='shots.matchTrxId',
           period='shots.period',
           secs='shots.periodSecs',
           squad.id='shots.squad.id',
           squad.name='shots.squad.name',
           squad.code='shots.squad.code',
           player.id='shots.player.id',
           player.name='shots.player.fullname',
           player.display='shots.player.displayName',
           origin='shots.details.origin',
           type='shots.details.type',
           distance='shots.details.distanceGroup',
           angle='shots.details.angleGroup',
           x='shots.details.locationRotated.x',
           y='shots.details.locationRotated.y',
           x.std='shots.details.locationRotated.xStd',
           y.std='shots.details.locationRotated.yStd',
           accuracy.exp='shots.result.accuracyExpected',
           result='shots.result.code',
           points.exp='shots.result.pointsExpected',
           points='shots.result.points')
}

#'Match Squad Stats
#'
#'Get squad stats for a match. Only returns observed metrics.
#'@param matchId A unique numerical identifier of a match.
#'@param period A numerical indicator of a period to filter results within a match. Accepts integer values.
#'@param zone A text indicator of a zone on the field to filter results within a match. Accepts string values "D50","DM","AM","F50".
#'@param context A text indicator of the context for squad statistics. Accepts "For" "Against" or "Diff".
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of metrics for a match for each squad.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{code} The metric code (ALL_CAPS format).
#'    \item \code{name} The metric name (singular).
#'    \item \code{plural} The metric name (plural).
#'    \item \code{value} The numeric metric value with no formatting applied.
#'    \item \code{display} The formatted metric value as a text string.
#'}
#'@examples
#'getSquadStats(216085122)
#'getSquadStats(216085122,period=1,zone='D50')
#'@export
getSquadStats <- function(matchId,period,zone,context,...){
  request_url <- paste('matches',matchId,'statistics/squads',sep='/')
  zcode <- NULL
  pcode <- NULL
  ccode <- NULL
  if(!missing(period)) pcode <- paste(paste('period=',period,sep=''),collapse='&')
  if(!missing(zone)) zcode <- paste(paste('zone=',zone,sep=''),collapse='&')
  if(!missing(context)) ccode <- paste(paste('context=',context,sep=''),collapse='&')
  qcode <- paste(pcode,zcode,ccode,sep='&')
  if(length(qcode)>0){
    if(substr(qcode,nchar(qcode),nchar(qcode))=='&') qcode <- substr(qcode,1,nchar(qcode)-1)
    if(substr(qcode,1,1)=='&') qcode <- substr(qcode,2,nchar(qcode))
    request_url <- paste(request_url,qcode,sep='?')
  }
  temp <- cdAPI(request_url,df=FALSE,...)
  if(is.null(temp)) return(NULL)
  r <- temp %>%
    content()
  home <- with(r$squads[[1]],data.frame(id,name,code,stringsAsFactors=FALSE))
  away <- with(r$squads[[2]],data.frame(id,name,code,stringsAsFactors=FALSE))
  homeStats <- do.call(bind_rows,lapply(r$squads[[1]]$statistics,unlist))
  awayStats <- do.call(bind_rows,lapply(r$squads[[2]]$statistics,unlist))
  if(dim(homeStats)[1]==0 & dim(awayStats)[1]==0) return(NULL)
  data.frame(match.id=matchId,bind_rows(data.frame(home,homeStats),data.frame(away,awayStats))) %>%
    select(match.id,
           squad.id='id',
           squad.name='name',
           squad.code='code',
           code='code.1',
           name='name.1',
           plural='namePlural',
           value,
           display='valueDisplay') %>%
    mutate(value=as.numeric(value))
}

#'Match Player Stats
#'
#'Get player stats for a match. Only returns observed metrics.
#'@param matchId A unique numerical identifier of a match.
#'@param period A numerical indicator of a period to filter results within a match. Accepts integer values.
#'@param zone A text indicator of a zone on the field to filter results within a match. Accepts string values "D50","DM","AM","F50".
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of metrics for a match for each player.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{player.id} A unique numerical identifier of the player.
#'    \item \code{player.name} The full name of the player.
#'    \item \code{player.display} The display name of the player, represented as first initial and surname.
#'    \item \code{code} The metric code (ALL_CAPS format).
#'    \item \code{name} The metric name (singular).
#'    \item \code{plural} The metric name (plural).
#'    \item \code{value} The numeric metric value with no formatting applied.
#'    \item \code{display} The formatted metric value as a text string.
#'}
#'@examples
#'getPlayerStats(216085122)
#'getPlayerStats(216085122,period=1,zone='D50')
#'@export
getPlayerStats <- function(matchId,period,zone,...){
  request_url <- paste('matches',matchId,'statistics/players',sep='/')
  zcode <- NULL
  pcode <- NULL
  if(!missing(period)) pcode <- paste(paste('period=',period,sep=''),collapse='&')
  if(!missing(zone)) zcode <- paste(paste('zone=',zone,sep=''),collapse='&')
  qcode <- paste(pcode,zcode,sep='&')
  if(length(qcode)>0){
    if(substr(qcode,nchar(qcode),nchar(qcode))=='&') qcode <- substr(qcode,1,nchar(qcode)-1)
    if(substr(qcode,1,1)=='&') qcode <- substr(qcode,2,nchar(qcode))
    request_url <- paste(request_url,qcode,sep='?')
  }
  temp <- cdAPI(request_url,df=FALSE,...)
  if(is.null(temp)) return(NULL)
  r <- temp %>%
    content()
  home <- with(r$squads[[1]],data.frame(id,name,code,stringsAsFactors=FALSE))
  away <- with(r$squads[[2]],data.frame(id,name,code,stringsAsFactors=FALSE))
  if(sum(unlist(lapply(r$squads[[1]]$players,function(x) length(x$statistics))))==0 & sum(unlist(lapply(r$squads[[2]]$players,function(x) length(x$statistics))))==0) return(NULL)
  homeStats <- do.call(bind_rows,lapply(r$squads[[1]]$players,function(x){
    details <- with(x,data.frame(personId,fullname,displayName,stringsAsFactors=FALSE))
    stats <- do.call(bind_rows,lapply(x$statistics,function(y) with(y,data.frame(code,name,namePlural,value,valueDisplay,stringsAsFactors = FALSE))))
    data.frame(details,stats,stringsAsFactors=FALSE)
  }))
  awayStats <- do.call(bind_rows,lapply(r$squads[[2]]$players,function(x){
    details <- with(x,data.frame(personId,fullname,displayName,stringsAsFactors=FALSE))
    stats <- do.call(bind_rows,lapply(x$statistics,function(y) with(y,data.frame(code,name,namePlural,value,valueDisplay,stringsAsFactors = FALSE))))
    data.frame(details,stats,stringsAsFactors=FALSE)
  }))
  data.frame(match.id=matchId,bind_rows(data.frame(home,homeStats),data.frame(away,awayStats))) %>%
    select(match.id,
           squad.id='id',
           squad.name='name',
           squad.code='code',
           player.id='personId',
           player.name='fullname',
           player.display='displayName',
           code='code.1',
           name='name.1',
           plural='namePlural',
           value,
           display='valueDisplay') %>%
    mutate(value=as.numeric(value))
}

#'Match Stat Leaders
#'
#'Get leading five players for selected stats for a match.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of the five leading players for selected metrics.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{code} The metric code (ALL_CAPS format).
#'    \item \code{name} The metric name (singular).
#'    \item \code{plural} The metric name (plural).
#'    \item \code{player.id} A unique numerical identifier of the player.
#'    \item \code{player.name} The full name of the player.
#'    \item \code{player.display} The display name of the player, represented as first initial and surname.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{value} The numeric metric value with no formatting applied.
#'    \item \code{display} The formatted metric value as a text string.
#'    \item \code{rank} Dense rank within metric, with ties presented as ties.method='min'.
#'    \item \code{order} Order within the metric with no ties. Ties in metric value are broken by ordering by player surname then firstname.
#'}
#'@examples
#'getLeaders(216085122)
#'@export
getLeaders <- function(matchId,...){
  temp <- cdAPI(paste('matches',matchId,'statistics/leaders',sep='/'),df=FALSE,...)
  if(is.null(temp)) return(NULL)
  r <- temp %>% content()
  stats <- do.call(bind_rows,lapply(r$statistics,function(x){
    details <- with(x,data.frame(code,name,namePlural,stringsAsFactors = FALSE))
    players <- do.call(bind_rows,lapply(x$persons,function(y) {
      if(!'valueDisplay'%in%names(y)) y <- c(y,'valueDisplay'=NA)
      with(y,data.frame(personId,fullname,displayName,squadId,squadName,squadCode,value,valueDisplay,rank,order,stringsAsFactors=FALSE))
    }))
    data.frame(details,players,stringsAsFactors=FALSE)
  }))
  data.frame(match.id='matchId',stats) %>%
    select(match.id,
           code,name,plural='namePlural',
           player.id='personId',
           player.name='fullname',
           player.display='displayName',
           squad.id='squadId',
           squad.name='squadName',
           squad.code='squadCode',
           value,display='valueDisplay',rank,order)
}

#'Period Scores
#'
#'Get a a list of match scores by quarter.
#'@param matchId A unique numerical identifier of a match.
#'@param cumulative Logical. Return scores up to and including that quarter? Defaults to FALSE, which returns scores within the quarter only.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of quarters and scores for each quarter.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{id} The transaction ID of the interchange move, used for ordering chronologically.
#'    \item \code{home.id} A unique numerical identifier of the home squad.
#'    \item \code{home.name} The name of the home squad.
#'    \item \code{home.code} A short code to represent the home squad.
#'    \item \code{away.id} A unique numerical identifier of the away squad.
#'    \item \code{away.name} The name of the away squad.
#'    \item \code{away.code} A short code to represent the away squad.
#'    \item \code{period} The period of the match.
#'    \item \code{home.goals} Goals scored by the home squad.
#'    \item \code{home.behinds} Behinds scored by the home squad.
#'    \item \code{home.points} Points scored by the home squad.
#'    \item \code{home.result} Period result for the home squad. W/L/D.
#'    \item \code{home.margin} Scoreboard margin for the home squad.
#'    \item \code{away.goals} Goals scored by the away squad.
#'    \item \code{away.behinds} Behinds scored by the away squad.
#'    \item \code{away.points} Points scored by the away squad.
#'    \item \code{away.result} Period result for the away squad. W/L/D.
#'    \item \code{away.margin} Scoreboard margin for the away squad.
#'    \item \code{winning.squad.id} The ID of the winning squad.
#'}
#'@examples
#'getPeriodScores(216085122)
#'getPeriodScores(216085122,cumulative=TRUE)
#'@export
getPeriodScores <- function(matchId,cumulative=FALSE,...){
  temp <- cdAPI(paste('matches',matchId,'score',sep='/'),...)
  if(is.null(temp)) return(NULL)
  temp <- temp %>%
    mutate(cumulative=cumulative,
           home.result.cumulative=case_when(home.periods.marginCumulative>0~'W',
                                            home.periods.marginCumulative<0~'L',
                                            TRUE~'D'),
           away.result.cumulative=case_when(home.periods.marginCumulative>0~'L',
                                            home.periods.marginCumulative<0~'W',
                                            TRUE~'D'),
           winning.squad.period=case_when(home.periods.margin>0~home.id,
                                          home.periods.margin<0~away.id,
                                          TRUE~NA_integer_),
           winning.squad.cumulative=case_when(home.periods.marginCumulative>0~home.id,
                                              home.periods.marginCumulative<0~away.id,
                                              TRUE~NA_integer_))
  if(!'home.periods.resultCode'%in%names(temp)) temp <- temp %>% mutate(home.periods.resultCode=NA)
  if(!'away.periods.resultCode'%in%names(temp)) temp <- temp %>% mutate(away.periods.resultCode=NA)
  temp %>%
    select(match.id='matchId',
           home.id,home.name,home.code,
           away.id,away.name,away.code,
           period='home.periods.period',
           home.goals=if_else(cumulative,'home.periods.goalsCumulative','home.periods.goals'),
           home.behinds=if_else(cumulative,'home.periods.behindsCumulative','home.periods.behinds'),
           home.points=if_else(cumulative,'home.periods.pointsCumulative','home.periods.points'),
           home.result=if_else(cumulative,'home.result.cumulative','home.periods.resultCode'),
           home.margin=if_else(cumulative,'home.periods.marginCumulative','home.periods.margin'),
           away.goals=if_else(cumulative,'away.periods.goalsCumulative','away.periods.goals'),
           away.behinds=if_else(cumulative,'away.periods.behindsCumulative','away.periods.behinds'),
           away.points=if_else(cumulative,'away.periods.pointsCumulative','away.periods.points'),
           away.result=if_else(cumulative,'away.result.cumulative','away.periods.resultCode'),
           away.margin=if_else(cumulative,'away.periods.marginCumulative','away.periods.margin'),
           winning.squad.id = if_else(cumulative,'winning.squad.cumulative','winning.squad.period'),
           cumulative)
}

#'Match Transactions
#'
#'Get the list of transactions for a match. Returns observed & not yet observed metrics.
#'
#'@import purrr
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of transactions for a match. 
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier for a match.
#'    \item \code{trx.id} A unique numerical identifier for a given transaction, used for ordering chronologically.
#'    \item \code{stat.code} The statistic code for a given transaction.
#'    \item \code{stat.desc} A short description of the statistic code for a transaction.  
#'    \item \code{period} The period of the transaction.
#'    \item \code{period.secs} The elapsed time within the period of a transaction. 
#'    \item \code{score.home} The score of the home squad.
#'    \item \code{score.away} The score of the away squad.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{squad.id} A unique numerical identifier for the squad.
#'    \item \code{person.fullname} The fullname of the player assigned to the transaction (if applicable).
#'    \item \code{person.displayName} The display name of the player assigned to the transaction (if applicable).
#'    \item \code{person.id} A unique numerical identifier for the player assigned to the transaction (if applicable).
#'    \item \code{pressure.squad.name} The name of the squad the pressure information is assigned to.
#'    \item \code{pressure.squad.id} A unique numerical identifier for the squad the pressure information is assigned to. 
#'    \item \code{pressure.squad.code} A short code to represent the squad the pressure information is assigned to.
#'    \item \code{pressure.name} The name of the type of pressure applied (ie. Set Position). 
#'    \item \code{pressure.code} A short code to represent the type of pressure applied.
#'    \item \code{pressure.points} The points value of the type of pressure applied.
#'    \item \code{pressure.fullname1} The fullname of the first pressure player.
#'    \item \code{pressure.displayname1} The display name of the first pressure player.
#'    \item \code{pressure.personid1} A unique numerical identifier for the first pressure player.
#'    \item \code{pressure.role1} The role number of the first pressure player (1).
#'    \item \code{pressure.fullname2} The fullname of the second pressure player.
#'    \item \code{pressure.displayname2} The display name of the second pressure player. 
#'    \item \code{pressure.personid2} A unique numerical identifier for the second pressure player.
#'    \item \code{pressure.role2} The role number of the second pressure player (2).
#'    \item \code{zone.physical} The zone in which the transaction takes place, relative to the physical ground.
#'    \item \code{zone.logical} The zone in which the transaction takes place, relative to the squad in possession.
#'    \item \code{location.x} The x coordinate of the transaction.
#'    \item \code{location.y} the y coordinate of the transaction.
#'    \item \code{location.x.std} The x coordinate of the transaction transformed to a standard ground dimension (160x141).
#'    \item \code{location.y.std} The y coordinate of the transaction transformed to a standard ground dimension (160x141).
#'    \item \code{location.rotated.x} The x coordinate of the transaction rotated to give all squads attacking left-to-right.
#'    \item \code{location.rotated.y} The y coordinate of the transaction rotated to give all squads attacking left-to-right.
#'    \item \code{location.rotated.x.std} The x coordinate of the transaction transformed to a standard ground dimension (160x141) & rotated to give all squads attacking left-to-right.
#'    \item \code{location.rotated.y.std} The y coordinate of the transaction transformed to a standard ground dimension (160x141) & rotated to give all squads attacking left-to-right.
#'    \item \code{kicking.foot} On kicking transactions, the foot of the kicking player.
#'    \item \code{kicking.intent} On kicking transactions, the intent of the kicking player.
#'    \item \code{kicking.distance} On kicking transactions, a description of the kicks distance.
#'    \item \code{kicking.direction} On kicking transactions, a description of the kicks direction.
#'    \item \code{inside50.direction} On inside 50 transactions, a description of the kicks direction.
#'    \item \code{inside50.intent} On inside 50 transactions, the intent of the kicking player.
#'    \item \code{shot.angle} A text description of the angle of the shot.
#'    \item \code{shot.distance} A text description of the distance of the shot.
#'    \item \code{shot.result} The result of the shot on goal (Does not include Goals).
#'    \item \code{shot.source} The source from which the shot on goal resulted (ie. General Play).
#'    \item \code{shot.type} The type of shot attempted (ie. General Play Snap).
#'    \item \code{freekick.context} On free kick transactions, the broad context from which the free kick was awarded.
#'    \item \code{freekick.reason} On free kick transactions, the specific reason the free kick was awarded.
#'    \item \code{kickin.direction} On kick in transactions, a text description of the direction taken from the kick in.
#'}
#'@examples
#'getMatchTransactions(216085122)
#'@export
getMatchTransactions <- function(matchId,...){
    
    # The columns that contain pressure info that require unnesting.
    pressurecols <- c("displayName", "fullname","personId","role")  
    
    # What we want to split the pressure info out into 
    newPressureCols <- c("pressure.displayname1","pressure.displayname2","pressure.fullname1","pressure.fullname2","pressure.personid1","pressure.personid2","pressure.role1","pressure.role2")
    
    # Empty DF of just second pressure player names for binding on when only one pressure player present in response
    secondPressurePlayerNames = data.frame("pressure.displayname2"=character(0),"pressure.fullname2"=character(0),"pressure.personid2"=character(0),"pressure.role2"=character(0))
    
    # Exhaustive list of possible columns
    availCols <- c('matchId', 'id' , 'name', 'code', 'period', 'periodSecs', 'homeScore', 'awayScore', 'squad.name', 'squad.code', 'squad.id', 'zonePhysical', 'zoneLogical', 'person.displayName', 'person.fullname', 'person.id', 'location.x', 'location.xStd', 'location.y', 'location.yStd','locationRotated.x', 'locationRotated.xStd', 'locationRotated.y', 'locationRotated.yStd','pressure.name', 'pressure.code', 'pressure.points', 'displayName', 'fullname', 'personId', 'role', 'pressure.squad.code' , 'pressure.squad.id', 'pressure.squad.name', 'kicking.foot', 'kicking.intent', 'kicking.distance', 'kicking.direction', 'details.freeKickReason', 'details.freeKickContext', 'details.inside50Direction' ,'details.inside50Intent','details.shotSource', 'details.shotType', 'details.shotAngle', 'details.shotDistance', 'details.shotResult' , 'details.kickinDirection')
    
    # Hit API
    temp <- cdAPI(paste('matches',matchId,"transactions",sep = '/'),df=TRUE,...) 
    
    if(is.null(temp)!=T){
        temp <- temp %>% # ADD ...
            dplyr::rename_with(~sub("^transactions\\.", "", .), dplyr::starts_with("transactions.")) %>%                                                                    # Remove 'transactions.' prefix
            { if ("pressure.players" %in% colnames(.)) tidyr::unnest_wider(., pressure.players) else . } %>%                                                                # Conditional; If pressure players is part of the response, unnest, if not continue.        
            dplyr::bind_rows(., data.frame(matrix(ncol = length(availCols))) %>% dplyr::rename_all(~availCols)) %>%                                                         # Bind on the empty df of all possible columns                 
            dplyr::slice(1:nrow(.)-1) %>%                                                                                                                                   # Remove the row created by empty bind                 
            dplyr::mutate(across(pressurecols, ~ purrr::map_chr(.x, toString))) %>%                                                                                         # Convert pressure columns of type vctrs_list_of to a char for delimiting
            dplyr::mutate(across(pressurecols, ~ replace(., . %in% c("","NA"), NA))) %>%                                                                                    # Handler for blanks or string NA as a result of conversion to char
            {
                { . -> tmp } %>%                                                                                                                                              # Take temporary object of data
                {data.frame(apply(.[pressurecols], 2, function(x) data.table::tstrsplit(x, ",")))} %>%                                                                        # Split out pressure columns appropriately
                { if (ncol(.)==8) purrr::set_names(.,newPressureCols) else purrr::set_names(., newPressureCols[c(1,3,5,7)]) %>% bind_rows(.,secondPressurePlayerNames) } %>%  # Conditional; If split out chunk has 8 cols (2 pressure players exist in response) rename using newPressureCols, if 4 cols (only 1 pressure player exists in respoonse) name the split out cols with the pressure player 1 names AND bind on the second pressure player names using empty secondPressurePlayerNames DF
                dplyr::bind_cols(tmp)                                                                                                                                         # Bind the flattened pressure columns back onto the tmp object
            }  %>% 
            select(                                                                                                                                                               # Select cols in appropriate order & rename where necessary
                # Match Context
                "match.id"= matchId ,
                "trx.id"= id ,
                "stat.code"= code ,
                "stat.desc"= name ,
                # Period
                period,
                "period.secs"= periodSecs,
                # Score
                "score.home"= homeScore,
                "score.away"= awayScore,
                # Squad
                squad.name,
                squad.code,
                squad.id,
                # Person
                person.fullname,
                person.displayName, 
                person.id , 
                # Pressure
                pressure.squad.name , 
                pressure.squad.id , 
                pressure.squad.code , 
                pressure.name,
                pressure.code, 
                pressure.points , 
                pressure.fullname1,
                pressure.displayname1 , 
                pressure.personid1 , 
                pressure.role1 , 
                pressure.fullname2 , 
                pressure.displayname2 ,
                pressure.personid2,
                pressure.role2 , 
                # Zone
                "zone.physical"= zonePhysical,
                "zone.logical"= zoneLogical,
                # Location
                location.x,
                location.y,
                "location.x.std"= location.xStd,
                "location.y.std"= location.yStd,
                "location.rotated.x"=locationRotated.x,
                "location.rotated.y"=locationRotated.y,
                "location.rotated.x.std"=locationRotated.xStd,
                "location.rotated.y.std"=locationRotated.yStd,
                # Kicking
                kicking.foot,
                kicking.intent, 
                kicking.distance, 
                kicking.direction , 
                # I50
                "inside50.direction"=details.inside50Direction,
                "inside50.intent"=details.inside50Intent,
                # Shot
                "shot.angle"=details.shotAngle ,
                "shot.distance"=details.shotDistance, 
                "shot.result"=details.shotResult,      
                "shot.source"=details.shotSource , 
                "shot.type"=details.shotType,
                # Free Kick
                "freekick.context"=details.freeKickContext ,
                "freekick.reason"=details.freeKickReason,
                # Kick In  
                "kickin.direction"=details.kickinDirection
            ) %>% 
            suppressWarnings()                
    }
    
    return(temp)
    
}  

#'Match Entries
#'
#'Get a list of Inside 50 entries for a match.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of inside 50 entries for a match, with one row per entry. NULL if the match is yet to start.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{entry.trx.id} The transaction ID of the entry, used for ordering chronologically.
#'    \item \code{entry.period} The period of the entry.
#'    \item \code{entry.period.secs} The elapsed time within the period of the entry.
#'    \item \code{entry.player.id} A unique numerical identifier of the player responsible for the entry.
#'    \item \code{entry.player.fullname} The fullname of the player responsible for the entry. 
#'    \item \code{entry.player.display.name} The display name of the player responsible for the entry.
#'    \item \code{entry.squad.id} A numerical identifier of the squad player responsible for the entry belongs to. 
#'    \item \code{entry.squad.name} The name of the squad the player responsible for the entry belongs to. 
#'    \item \code{entry.squad.code} A short code to represent the squad the player responsible for the entry belongs to. 
#'    \item \code{entry.type} The type of inside 50 entry.
#'    \item \code{entry.source.name} The game situation relative to the origin of a team's possession that results in an entry.
#'    \item \code{entry.source.type} Inside 50 entries where direct indicates the first chain after the specified entry.source.name 
#'    
#'    For centre bounce and midfield stoppage \code{entry.source.name}, direct indicates the entry was in the clearance chain \cr
#'    
#'    For repeat \code{entry.source.name}, direct indicates the entry was on the first turnover chain after an opposition rebound 50 \cr
#'    
#'    For transition \code{entry.source.name}, direct indicates the entry was in the same chain as the rebound 50
#'    \item \code{entry.kick.is.ground} For inside 50 entries that are kicks, was the entry from a ground kick (true/false).
#'    \item \code{entry.kick.foot} For inside 50 entries that are kicks, which foot did the kicking player use.
#'    \item \code{entry.kick.intent} For inside 50 entries that are kicks, the intent of the kicker. 
#'    \item \code{entry.kick.distance} For inside 50 entries that are kicks, the distance of the kick.
#'    \item \code{entry.kick.direction} For inside 50 entries that are kicks, the direction of the kick
#'    \item \code{entry.kick.launch.distance.to.goal} For inside 50 entries that are kicks, the straight line distance to goal from the launch point of the kick.
#'    \item \code{entry.kick.result.distance.to.goal} For inside 50 entries that are kicks, the straight line distance to goal from the result point of the kick.
#'    \item \code{entry.kick.pressure.name} For inside 50 entries that are kicks, the name of the type of pressure applied to the kicker.
#'    \item \code{entry.kick.pressure.code} For inside 50 entries that are kicks, a short code to describe the type of pressure applied to the kicker.
#'    \item \code{entry.kick.pressure.points} For inside 50 entries that are kicks, the number of points associated with the pressure type applied to the kicker.
#'    \item \code{entry.kick.launch.location.x} The x coordinate of the inside 50 launch location.
#'    \item \code{entry.kick.launch.location.y} The y coordinate of the inside 50 launch location.
#'    \item \code{entry.kick.launch.location.x.std} The x coordinate of the inside 50 launch location transformed to a standard ground dimension (160x141).
#'    \item \code{entry.kick.launch.location.y.std} The y coordinate of the inside 50 launch location transformed to a standard ground dimension (160x141).
#'    \item \code{entry.kick.launch.location.rotated.x} The x coordinate of the inside 50 launch location rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.launch.location.rotated.y} The y coordinate of the inside 50 launch location rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.launch.location.rotated.x.std} The x coordinate of the inside 50 launch location transformed to a standard ground dimension (160x141) & rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.launch.location.rotated.y.std} The x coordinate of the inside 50 launch location transformed to a standard ground dimension (160x141) & rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.result.location.x} The x coordinate of the inside 50 result location. 
#'    \item \code{entry.kick.result.location.y} The y coordinate of the inside 50 result location. 
#'    \item \code{entry.kick.result.location.x.std} The x coordinate of the inside 50 result location transformed to a standard ground dimension (160x141).
#'    \item \code{entry.kick.result.location.y.std} The y coordinate of the inside 50 result location transformed to a standard ground dimension (160x141).
#'    \item \code{entry.kick.result.location.rotated.x} The x coordinate of the inside 50 result location rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.result.location.rotated.y} The y coordinate of the inside 50 result location rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.result.location.rotated.x.std} The x coordinate of the inside 50 result location transformed to a standard ground dimension (160x141) & rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.result.location.rotated.y.std} The y coordinate of the inside 50 result location transformed to a standard ground dimension (160x141) & rotated to give all squads attacking left-to-right.
#'}
#'@examples
#'getEntries(216085122)
#'@export
getEntries <- function(matchId,...){
    
    # Hit entries endpoint
    temp <- cdAPI(paste('matches',matchId,'entries',sep='/'),...)
    
    if(is.null(temp)) {
        message(temp)
        return(NULL)
    } else if(all(dim(temp) == c(1, 1))){ # mid not found handler
        message(temp)
        return(NULL)
    } else {
        temp = temp %>%
            dplyr::rename_with(~str_remove(., "entries\\.|entries.details.source\\.|entries.details.\\."), everything()) %>%
            dplyr::rename_with(~str_remove(., "details\\."), everything()) %>%
            dplyr::rename_with(~str_replace_all(., "(?<=[a-z])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])", ".")) %>%
            dplyr::rename_all(tolower) %>%
            dplyr::rename_at(vars(-"match.id"), ~paste0("entry.", .)) %>% 
            dplyr::rename("entry.trx.id" = entry.id)
        return(temp)
    }
}
