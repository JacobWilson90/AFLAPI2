#'Match Chains
#'
#'Get a list of possession chains for a match.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of possession chains for a match, with one row per chain. NULL if the match is yet to start.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{squad.name} The name of the squad in possession during the chain.
#'    \item \code{squad.code} A short code to represent the squad in possession during the chain.
#'    \item \code{period} The period of the possession chain.
#'    \item \code{start.id} The transaction ID of the start of the chain.
#'    \item \code{start.secs} The elapsed time within the period at the start of the chain.
#'    \item \code{start.name} The starting state of the chain.
#'    \item \code{start.code} A short code representing the starting state of the chain.
#'    \item \code{start.type} The start type of the chain.
#'    \item \code{start.type.code} A short code representing the starting type of the chain.
#'    \item \code{start.zone} The starting zone of the chain, relative to the squad in possession.
#'    \item \code{start.zone.physical} The starting zone of the chain, relative to the physical ground.
#'    \item \code{start.x} The x-coordinate of the start of chain location.
#'    \item \code{start.y} The y-coordinate of the start of chain location.
#'    \item \code{launch.id} A unique numerical identifier of the player who launched the chain.
#'    \item \code{launch.name} The full name of the player who launched the chain.
#'    \item \code{launch.display} The display name of the player who launched the chain, represented as first initial and surname.
#'    \item \code{end.id} The transaction ID of the end of the chain.
#'    \item \code{end.secs} The elapsed time within the period at the end of the chain.
#'    \item \code{end.name} The final state of the chain.
#'    \item \code{end.code} A short code representing the final state of the chain.
#'    \item \code{end.type} The end type of the chain.
#'    \item \code{end.type.code} A short code representing the end type of the chain.
#'    \item \code{end.zone} The final zone of the chain, relative to the squad in possession.
#'    \item \code{end.zone.physical} The final zone of the chain, relative to the physical ground.
#'    \item \code{end.x} The x-coordinate of the end of chain location.
#'    \item \code{end.y} The y-coordinate of the end of chain location.
#'    \item \code{score.id} The transaction ID of the scoring shot, if a score was generated during the chain.
#'    \item \code{score.result} A single letter representing the result scoring of the scoring shot, if a score was generated during the chain.
#'    \item \code{score.result.name} The full name of the result scoring shot, if a score was generated during the chain.
#'    \item \code{score.points} The points generated by the scoring shot, if a score was generated during the chain.
#'    \item \code{score.player.id} A unique numerical identifier of the player who scored within the chain.
#'    \item \code{score.player.name} The full name of the player who scored within the chain.
#'    \item \code{score.player.display} The display name of the player who scored within the chain, represented as first initial and surname.
#'    \item \code{turnover.player.id} A unique numerical identifier of the player who turned the ball over at the end of the chain.
#'    \item \code{turnover.player.name} The full name of the player who turned the ball overa at the end of the chain.
#'    \item \code{turnover.player.display} The display name of the player who turned the ball overa at the end of the chain, represented as first initial and surname.
#'    \item \code{turnover.type} The type of turnover that was commited. Kick, handball or non-disposal.
#'    \item \code{turnover.state} The match state of the turnover that was commited. Clearing stoppage or General Play.
#'    \item \code{turnover.creation} The creation method of the turnover that was commited. Forced/Unforced Giveaway or Opposition Takeaway.
#'    \item \code{clearance.id} The transaction ID of the clearance that was won within the chain.
#'    \item \code{inside50.id} The transaction ID of the first inside 50 that was generated by the squad in possession within the chain.
#'    \item \code{rebound50.id} The transaction ID of the first rebound 50 that was generated by the squad in possession within the chain.
#'    \item \code{stoppage.id} The first transaction ID of the chain in a stoppage chain.
#'    \item \code{next.id} The transaction ID of the start of the next possession chain.
#'    \item \code{prevoius.id} The transaction ID of the start of the previous possession chain.
#'    \item \code{chain.metres.gained} Metres gained by a team within possession chains, combining measures towards attacking goal and away from defensive goal.
#'    \item \code{chain.metres.gained.reply} Chain Metres conceded to the opposition in the next chain after a turnover.
#'    \item \code{chain.metres.gained.net} Net Metres gained in a chain of possession after subtracting opposition Metres gained after a turnover. Equal to Chain Metres minus Chain Metres Reply.
#'}
#'@examples
#'getChains(216085122)
#'@export
getChains <- function(matchId,...){
  
  # Hit endpoint for response
  rawResponse <- cdAPIresponse(matchId,paste('matches',matchId,'chains',sep='/'),...)
  
  if(is.null(rawResponse)){
    return(rawResponse)
  } else {
    # Convert response to flat list
    listResponse <- rawResponse %>% resp_body_json(simplifyVector = TRUE)
    
    # Handle if successful response but no events happened yet (second element of list empty)
    if(is_empty(listResponse[[2]])) {
      returnData        <- data.frame(matrix(ncol = length(getChainsWhitelist), nrow = 0))
      names(returnData) <- getChainsWhitelist
      message(paste0("\nWarning:\n--> 0 rows of data in response.")) 
      return(returnData)
    } else {
      # Convert list into DF
      returnData <- listResponse %>% as.data.frame() %>% jsonlite::flatten()
      
      # Get vector of the missing fields (IF ANY) in the call info
      missing <- setdiff(getChainsWhitelist,names(returnData))
      
      # Add on any of the missing columns in the response 
      returnData[missing] <- lapply(missing, function(x) rep(NA, nrow(returnData)))
    }
    # Select exposed fields (getChainsExposedFields) & rename columns
    returnData        <- returnData[, getChainsExposedFields]
    names(returnData) <- names(getChainsExposedFields)
    
    return(returnData)
  }
}

#'Match Rotations
#'
#'Get a dataframe of rotations for a match.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with all of the rotations for a given match. 
#' \itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{squad.name} The name of the squad the rotation player belongs to.
#'    \item \code{squad.code} A short code to represent the squad the rotation player belongs to.
#'    \item \code{squad.id} A unique numerical identifier of the squad the rotation player belongs to.
#'    \item \code{period} The period the rotation occured in.
#'    \item \code{secs} The elapsed time within the period the rotation occured in.
#'    \item \code{id} The transaction ID of the rotation, used for ordering chronologically.
#'    \item \code{off.name} The full name of the player coming off the ground.
#'    \item \code{off.display} The display name of the player coming off the ground, represented as first initial and surname.
#'    \item \code{off.id} A unique numerical identifier of the player coming off the ground.
#'    \item \code{on.name} The full name of the player coming on the ground. Empty for start-of-match initialisation of the interchange bench.
#'    \item \code{on.display} The display name of the player coming on the ground, represented as first initial and surname. Empty for start-of-match initialisation of the interchange bench.
#'    \item \code{on.id} A unique numerical identifier of the player coming on the ground. Empty for start-of-match initialisation of the interchange bench.
#'    \item \code{off.reason} The reason for the rotation  (ie.\code{'Regular' , 'Injured'}.)
#'    \item \code{off.code} A short text description of the reason for the rotation (ie.\code{'REG' , 'INJ'}.)
#'    \item \code{squad.name} (when \code{currentStints = TRUE}) The name of the squad a given players rotation stint belongs to.
#'    \item \code{squad.code} (when \code{currentStints = TRUE}) A short code to represent the squad a given players rotation stint belongs to.
#'    \item \code{squad.id} (when \code{currentStints = TRUE}) A unique numerical identifier of the squad a given players rotation stint belongs to.
#'    \item \code{player.fullname} (when \code{currentStints = TRUE}) The full name of the player the rotation stint belongs to.
#'    \item \code{player.display.name} (when \code{currentStints = TRUE}) The display name of the player the rotation stint belongs to, represented as first initial and surname.
#'    \item \code{player.id} (when \code{currentStints = TRUE}) A unique numerical identifier of the player the rotation stint belongs to.
#'    \item \code{current.stint.period} (when \code{currentStints = TRUE}) The period the given rotation stint occurred in.
#'    \item \code{current.stint.period.secs} (when \code{currentStints = TRUE}) The period seconds value that the given rotation stint started
#'    \item \code{current.stint.elapsed.secs} (when \code{currentStints = TRUE}) The elapsed seconds that the given stint has been going for. 
#'    \item \code{current.stint.status} (when \code{currentStints = TRUE}) The status of the given rotation stint (ie.\code{'ON' , 'OFF'}.)
#'    \item \code{current.stint.reason} (when \code{currentStints = TRUE}) The reason for the given rotation stint (ie.\code{'Regular' , 'Injured'}.)
#'    \item \code{current.stint.reason.code} (when \code{currentStints = TRUE}) A short text description of the reason for the given rotation stint (ie.\code{'REG' , 'INJ'}.)
#' }
#'@examples
#'getRotations(matchId = 120390401)
#'@export
getRotations <- function(matchId, currentStints = FALSE, ...){
  
  # Hit endpoint for response
  rawResponse <- cdAPIresponse(matchId, paste('matches',matchId,'rotations',sep='/'), ...) 
  
  if(is.null(rawResponse)){
    return(rawResponse)
  } else {
    
    # Convert response to flat list
    listResponse <- rawResponse %>% resp_body_json(simplifyVector = TRUE)
    
    # If user wants the current stints...
    if(currentStints == TRUE){
      
      # Home current stint
      currentStintHome        <- as.data.frame(listResponse$home) %>% jsonlite::flatten()
      # Away current stint
      currentStintAway        <- as.data.frame(listResponse$away) %>% jsonlite::flatten()
      
      # Combine the home/away current stint dataframes
      returnData              <- bind_rows(currentStintHome, currentStintAway)
      
      # Add matchId which isnt present in this layer of the response
      returnData$match.id     <- listResponse$matchId
      
      # Get vector of the missing fields (IF ANY) in the call info
      missing <- setdiff(getRotations_HomeAwayStintsExposedFields, names(returnData))
      
      # Add on any of the missing columns in the response 
      returnData[missing] <- lapply(missing, function(x) rep(NA, nrow(returnData)))
      
      # Select exposed fields (getRotations_HomeAwayStintsExposedFields) & rename columns
      returnData        <- returnData[, getRotations_HomeAwayStintsExposedFields]
      names(returnData) <- names(getRotations_HomeAwayStintsExposedFields)
      
      # order by stint.status (off first, then on) and squad name (home squad first, then away)
      returnData              <- returnData[order(factor(returnData$current.stint.status, levels = c("OFF","ON")) , 
                                                  factor(returnData$squad.name, levels = c(currentStintHome$squad.name[1], currentStintAway$squad.name[1]))), ]
      
    } else {
      
      # Handle if successful response but no events happened yet (second element of list empty)
      if(is_empty(listResponse$rotations)) {
        returnData        <- data.frame(matrix(ncol = length(getRotationsWhitelist), nrow = 0))
        names(returnData) <- getRotationsWhitelist
        message(paste0("\nWarning:\n--> 0 rows of data in response.")) 
        return(returnData)
      }
      # flatten into DF
      returnData          <- listResponse$rotations %>% jsonlite::flatten()
      
      # Add matchId which isnt present in this layer of the response
      returnData$match.id <- listResponse$matchId
      
      # Get vector of the missing fields (IF ANY) in the call info
      missing             <- setdiff(getRotationsWhitelist,names(returnData))
      
      # Add on any of the missing columns in the response 
      returnData[missing] <- lapply(missing, function(x) rep(NA, nrow(returnData)))
      
      # Select exposed fields (getRotationsExposedFields) & rename columns
      returnData          <- returnData[, getRotationsExposedFields]
      names(returnData)   <- names(getRotationsExposedFields)
      
    } # CLOSE // if-else (currentStints == TRUE)
  } # CLOSE // if-else (is.null(rawResponse))
  return(returnData)
}

#'Match Shots
#'
#'Get a list of shots at goal for a match. Also includes rushed behinds.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of shots at goal for a match, with one row per shot.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{id} The transaction ID of the shot, used for ordering chronologically.
#'    \item \code{period} The period of the shot.
#'    \item \code{secs} The elapsed time within the period of the shot.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{player.id} A unique numerical identifier of the player taking the shot.
#'    \item \code{player.name} The full name of the player taking the shot.
#'    \item \code{player.display} The display name of the player taking the shot, represented as first initial and surname.
#'    \item \code{origin} How the player was able to generate a shot at goal.
#'    \item \code{type} The type of shot attempted.
#'    \item \code{angle} A text description of the angle of the shot.
#'    \item \code{distance} A text description of the distance of the shot.
#'    \item \code{x} Distance of the shot in metres from the centre of the ground (measuring horizontally from goal to goal), with the goals being at positive (venue_length / 2).
#'    \item \code{y} Distance of the shot in metres from the centre of the ground (measuring vertically from wing to wing), with the goals being at zero and the boundary line at halfway being at (venue_width / 2). Positive y is bottom of screen when running to the right.
#'    \item \code{x.std} The x coordinate of the shot transformed to a standard ground dimension (160x141).
#'    \item \code{y.std} The y coordinate of the shot transformed to a standard ground dimension (160x141).
#'    \item \code{accuracy.exp} The expected accuracy of the shot.
#'    \item \code{result} The result of the shot. G / B / R / M.
#'    \item \code{points.exp} The expected points of the shot.
#'    \item \code{points} The number of points obtained from the shot.
#'}
#'@examples
#'getShots(216085122)
#'@export
getShots <- function(matchId,...){
  
  # Hit endpoint for response
  rawResponse <- cdAPIresponse(endpoint = paste('matches',matchId,'shots',sep='/'),...)
  
  if(is.null(rawResponse)){
    return(rawResponse)
  } else {
    # Convert response to flat list
    listResponse <- rawResponse %>% resp_body_json(simplifyVector = TRUE)
    
    # Handle if successful response but no events happened yet (second element of list empty)
    if(is_empty(listResponse[[2]])) {
      returnData        <- data.frame(matrix(ncol = length(getShotsExposedFields), nrow = 0))
      names(returnData) <- getShotsExposedFields
      message(paste0("\nWarning:\n--> 0 rows of data in response.")) 
      return(returnData)
    } else {
      # Convert list into DF
      returnData <- listResponse %>% as.data.frame() %>% jsonlite::flatten()
      
      # Get vector of the missing fields (IF ANY) in the call info
      missing <- setdiff(getShotsExposedFields,names(returnData))
      
      # Add on any of the missing columns in the response 
      returnData[missing] <- lapply(missing, function(x) rep(NA, nrow(returnData)))
    }
    
    # Select exposed fields (getShotsExposedFields) & rename columns
    returnData        <- returnData[, getShotsExposedFields]
    names(returnData) <- names(getShotsExposedFields)
    
    return(returnData)
  }
} 

#'Match Squad Stats
#'
#'Get squad stats for a match. Only returns observed metrics.
#'@param matchId A unique numerical identifier of a match.
#'@param period A numerical indicator of a period to filter results within a match. Accepts integer values.
#'@param zone A text indicator of a zone on the field to filter results within a match. Accepts string values: \code{"D50","DM","AM","F50","CB"}.
#'@param context A text indicator of the context for squad statistics. Accepts "For" "Against" or "Diff".
#'@param metric A text string of specific metric code(s) to be returned. This will result in the endpoint only returning these specific metrics. Note this endpoint is case sensitive and only works with metric codes (ie. \code{c("TACKLE", "GOAL")}
#'@param team A (case-sensitive) text string of the team to return metrics for. Either \code{"home"} or \code{"away"}. Not passing anything to this param will return both teams.
#'@param lastXseconds An integer that limits statistics to counting events that occurred in the last X number of seconds. (ie. \code{lastXSeconds = 300} will return the last 5 minutes)
#'@param from Limits statistics to counting events that occurred on or after this number of seconds (ie. \code{from = 300} will return statistics that occured on or after the 300th second into the match)
#'@param to Limits statistics to counting events that occurred on or before this number of seconds (ie. \code{to = 300} will return statistics that occured up to (and including) the 300th second into the match)
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of metrics for a match for each squad.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{code} The metric code (ALL_CAPS format).
#'    \item \code{name} The metric name (singular).
#'    \item \code{id} The unique numerical identifier for the given statistic code.
#'    \item \code{plural} The metric name (plural).
#'    \item \code{value} The numeric metric value with no formatting applied.
#'    \item \code{display} The formatted metric value as a text string.
#'}
#'@examples
#'getSquadStats(216085122)
#'getSquadStats(216085122,period=1,zone='D50',from = 0, to = 300)
#'@export
getSquadStats <- function(matchId, period = NULL, zone = NULL, context = NULL, metric = NULL, team = NULL, lastXseconds = NULL, from = NULL, to = NULL, ...) {
  
  if(!missing(lastXseconds) && (!missing(from) || !missing(to))) {
    message(paste0("\nError:\n--> 'lastXseconds' parameter cannot be passed in to getSquadStats() alongside the 'from' or 'to' parameter(s)."))
    return(NULL)
  }
  
  # Base URL
  baseString   <- paste('matches',matchId,'statistics/squads?',sep='/') 
  
  # Hit API
  rawResponse <- cdAPIresponse(endpoint = paste0(baseString, optionalParams(
    "period"       = period , 
    "zone"         = zone , 
    "context"      = context , 
    "metric"       = metric , 
    "team"         = team , 
    "lastXseconds" = lastXseconds , 
    "from"         = from , 
    "to"           = to 
  )), ...)
  
  if(is.null(rawResponse)) {
    return(rawResponse)
  } else {
    # Convert response to flat list
    listResponse <- rawResponse %>% resp_body_json(simplifyVector = TRUE)
    
    # Convert list into DF
    returnData <- listResponse %>% as.data.frame() %>% jsonlite::flatten()
    
    # Continue to unnest    
    returnData <- returnData %>% 
      tidyr::unnest("squads.statistics", names_sep = "_") 
    
    # Handle if no rows are present at the time of the call based on inputs
    if(nrow(returnData) == 0) {
      message(paste0("\nWarning:\n--> 0 rows of data for the parameters supplied.")) 
      
      # Add on the statistic-relevant columns that don't populate when there is zero data to be returned
      returnData[getSquadStatsMissingFields] <- lapply(getSquadStatsMissingFields, function(x) rep(NA, nrow(returnData)))
    } 
    
    # Select exposed fields (getSquadStatsExposedFields) & rename columns
    returnData        <- returnData[, getSquadStatsExposedFields]
    names(returnData) <- names(getSquadStatsExposedFields)
  }
  return(returnData)
}

#'Match Player Stats
#'
#'Get player stats for a match. Only returns observed metrics.
#'@param matchId A unique numerical identifier of a match.
#'@param period A numerical indicator of a period to filter results within a match. Accepts integer values.
#'@param zone A text indicator of a zone on the field to filter results within a match. Accepts string values: \code{"D50","DM","AM","F50","CB"}.
#'@param metric A text string of specific metric code(s) to be returned. This will result in the endpoint only returning these specific metrics. Note this endpoint is case sensitive and only works with metric codes (ie. \code{c("TACKLE", "GOAL")}
#'@param team A (case-sensitive) text string of the team to return metrics for. Either \code{"home"} or \code{"away"}. Not passing anything to this param will return both teams.
#'@param lastXseconds An integer that limits statistics to counting events that occurred in the last X number of seconds. (ie. \code{lastXSeconds = 300} will return the last 5 minutes)
#'@param from Limits statistics to counting events that occurred on or after this number of seconds (ie. \code{from = 300} will return statistics that occured on or after the 300th second into the match)
#'@param to Limits statistics to counting events that occurred on or before this number of seconds (ie. \code{to = 300} will return statistics that occured up to (and including) the 300th second into the match)
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of metrics for a match for each player.
#'\itemize{
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{player.id} A unique numerical identifier of the player.
#'    \item \code{player.name} The full name of the player.
#'    \item \code{player.display} The display name of the player, represented as first initial and surname.
#'    \item \code{code} The metric code (ALL_CAPS format).
#'    \item \code{name} The metric name (singular).
#'    \item \code{id} The unique numerical identifier for the given statistic code.
#'    \item \code{plural} The metric name (plural).
#'    \item \code{value} The numeric metric value with no formatting applied.
#'    \item \code{display} The formatted metric value as a text string.
#'}
#'@examples
#'getPlayerStats(216085122)
#'getPlayerStats(216085122,period=1,zone='D50',from = 0,to = 300)
#'@export
getPlayerStats <- function(matchId, period = NULL, zone = NULL, metric = NULL, team = NULL, lastXseconds = NULL, from = NULL, to = NULL, ...) {
  
  if(!missing(lastXseconds) && (!missing(from) || !missing(to))) {
    message(paste0("\nError:\n--> 'lastXseconds' parameter cannot be passed in to getPlayerStats() alongside the 'from' or 'to' parameter(s)."))
    return(NULL)
  }
  
  # Base URL
  baseString   <- paste('matches',matchId,'statistics/players?',sep='/')                                                 
  
  # Hit API
  rawResponse <- cdAPIresponse(endpoint = paste0(baseString, optionalParams(
    "period"       = period , 
    "zone"         = zone , 
    "metric"       = metric , 
    "team"         = team , 
    "lastXseconds" = lastXseconds , 
    "from"         = from , 
    "to"           = to 
  )), ...)
  
  if(is.null(rawResponse)) {
    return(rawResponse)
  } else {
    # Convert response to flat list
    listResponse <- rawResponse %>% resp_body_json(simplifyVector = TRUE)
    
    # Convert list into DF
    returnData <- listResponse %>% as.data.frame() %>% jsonlite::flatten()
    
    # Continue to unnest    
    returnData <- returnData %>% 
      tidyr::unnest("squads.players", names_sep = "_") 
    
    # Get vector of indexes of type list in squads.players_statistics
    listRows <- which(sapply(returnData$squads.players_statistics,class)=="list")
    
    # Extract data out of listResponse
    returnData <- returnData %>%
      filter(!(row_number() %in% listRows)) %>% # If any rows are of class list - remove them before unnesting below (will generate error)  
      tidyr::unnest("squads.players_statistics", names_sep = "_")
    
    # Handle if no rows are present at the time of the call based on inputs
    if(nrow(returnData) == 0) {
      message(paste0("\nWarning:\n--> 0 rows of data for the parameters supplied.")) 
      
      # Add on the statistic-relevant columns that don't populate when there is zero data to be returned
      returnData[getPlayerStatsMissingFields] <- lapply(getPlayerStatsMissingFields, function(x) rep(NA, nrow(returnData)))
    } 
    
    # Select exposed fields (getPlayerStatsExposedFields) & rename columns
    returnData        <- returnData[, getPlayerStatsExposedFields]
    names(returnData) <- names(getPlayerStatsExposedFields)
  }
  return(returnData)
}

#'Match Stat Leaders
#'
#'Get leading five players for selected stats for a match.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of the five leading players for selected metrics.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{code} The metric code (ALL_CAPS format).
#'    \item \code{name} The metric name (singular).
#'    \item \code{plural} The metric name (plural).
#'    \item \code{id} A unique numerical identifier of a metric.
#'    \item \code{player.id} A unique numerical identifier of the player.
#'    \item \code{player.name} The full name of the player.
#'    \item \code{player.display} The display name of the player, represented as first initial and surname.
#'    \item \code{player.jumper.number} The jumper number worn on the players's uniform.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{value} The numeric metric value with no formatting applied.
#'    \item \code{display} The formatted metric value as a text string.
#'    \item \code{rank} Dense rank within metric, with ties presented as ties.method='min'.
#'    \item \code{order} Order within the metric with no ties. Ties in metric value are broken by ordering by player surname then firstname.
#'}
#'@examples
#'getLeaders(216085122)
#'@export
getLeaders <- function(matchId,...){  
  
  # Hit API
  rawResponse <- cdAPIresponse(matchId,paste('matches',matchId,'statistics/leaders',sep='/'),...)
  
  if(is.null(rawResponse)){
    return(rawResponse)
  } else {
    
    # Convert response to flat list
    listResponse <- rawResponse %>% resp_body_json(simplifyVector = TRUE)
    
    # Convert list into DF
    returnData <- listResponse %>% as.data.frame() %>% jsonlite::flatten()
    
    # Unnest the list col containing data
    returnData <- returnData %>% 
      tidyr::unnest("statistics.persons", names_sep = "_") 
    
    # Get vector of the missing fields (IF ANY) in the call info
    missing <- setdiff(getLeadersWhitelist,names(returnData))
    
    # Add on any of the missing columns in the response 
    returnData[missing] <- lapply(missing, function(x) rep(NA, nrow(returnData)))
    
    # Select exposed fields (getLeadersExposedFields) & rename columns
    returnData        <- returnData[, getLeadersExposedFields]
    names(returnData) <- names(getLeadersExposedFields)
    
    # Set any NA instances of value display column to 0 
    returnData$display[is.na(returnData$display)] <- 0
    
    return(returnData)
  }
}

#'Period Scores
#'
#'Get a a list of match scores by quarter.
#'@param matchId A unique numerical identifier of a match.
#'@param cumulative Logical. Return scores up to and including that quarter? Defaults to FALSE, which returns scores within the quarter only.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of quarters and scores for each quarter.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{period} The period of the match.
#'    \item \code{home.name} The name of the home squad.
#'    \item \code{home.code} A short code to represent the home squad.
#'    \item \code{home.id} A unique numerical identifier of the home squad.
#'    \item \code{home.goals} Goals scored by the home squad.
#'    \item \code{home.behinds} Behinds scored by the home squad.
#'    \item \code{home.points} Points scored by the home squad.
#'    \item \code{home.margin} Scoreboard margin for the home squad.
#'    \item \code{home.period.result} Period result for the home squad \code{Win/Loss/Draw}
#'    \item \code{home.period.result.code} Period result code for the home squad \code{W/L/D}
#'    \item \code{home.match.result} Match result for the home squad \code{W/L/D}
#'    \item \code{away.name} The name of the away squad.
#'    \item \code{away.code} A short code to represent the away squad.
#'    \item \code{away.id} A unique numerical identifier of the away squad.
#'    \item \code{away.goals} Goals scored by the away squad.
#'    \item \code{away.behinds} Behinds scored by the away squad.
#'    \item \code{away.points} Points scored by the away squad.
#'    \item \code{away.margin} Scoreboard margin for the away squad.
#'    \item \code{away.period.result} Period result for the away squad \code{Win/Loss/Draw}
#'    \item \code{away.period.result.code} Period result code for the away squad \code{W/L/D}
#'    \item \code{away.match.result} Match result for the away squad \code{W/L/D}
#'    \item \code{winning.squad.id.period} The squad ID of the winning squad for the given period.
#'    \item \code{winning.squad.id.match} The squad ID of the winning squad for the match.
#'    \item \code{cumulative} TRUE/FALSE based on the \code{cumulative} parameter passed to the function.
#'}
#'@examples
#'getPeriodScores(216085122)
#'getPeriodScores(216085122,cumulative=TRUE)
#'@export
getPeriodScores <- function(matchId,cumulative=FALSE,...){
  
  rawResponse <- cdAPIresponse(endpoint = paste('matches',matchId,'score',sep='/'),...)
  
  if(is.null(rawResponse)){
    return(rawResponse)
  } else {
    
    # Convert response to flat list
    listResponse <- rawResponse %>% resp_body_json(simplifyVector = TRUE)
    
    # Convert list into DF
    returnData <- listResponse %>% as.data.frame() %>% jsonlite::flatten()
    
    # Get vector of the missing fields (IF ANY) in the call info
    missing <- setdiff(getPeriodScoresWhitelist,names(returnData))
    
    # Add on any of the missing columns in the response 
    returnData[missing] <- lapply(missing, function(x) rep(NA, nrow(returnData)))
    
    if(cumulative){
      returnData        <- returnData[, getPeriodScoresExposedFields_cumulative]  
      names(returnData) <- names(getPeriodScoresExposedFields_cumulative)
    } else {
      returnData        <- returnData[, getPeriodScoresExposedFields ]
      names(returnData) <- names(getPeriodScoresExposedFields)
    }
    
    # Engineered fields that always existed that need to be supported
    returnData$"winning.squad.id.period" <- ifelse(returnData$home.margin > 0, returnData$home.id,
                                            ifelse(returnData$home.margin < 0, returnData$away.id,NA_integer_))
    returnData$"winning.squad.id.match"  <- ifelse(returnData$home.match.result == "Win" ,returnData$home.id,
                                            ifelse(returnData$home.match.result == "Loss",returnData$away.id,NA_integer_))
    returnData$"cumulative"              <- cumulative
    
    return(returnData)
  }
}

#'Match Transactions
#'
#'Get the list of transactions for a match. Returns a dataframe with fixed column length, irrespective of any fields having recorded values for match or not.
#'
#'@import purrr
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of transactions for a match. 
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier for a match.
#'    \item \code{trx.id} A unique numerical identifier for a given transaction, used for ordering chronologically.
#'    \item \code{stat.code} The statistic code for a given transaction.
#'    \item \code{stat.desc} A short description of the statistic code for a transaction.  
#'    \item \code{period} The period of the transaction.
#'    \item \code{period.secs} The elapsed time within the period of a transaction. 
#'    \item \code{score.home} The score of the home squad.
#'    \item \code{score.away} The score of the away squad.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{squad.id} A unique numerical identifier for the squad.
#'    \item \code{person.fullname} The fullname of the player assigned to the transaction (if applicable).
#'    \item \code{person.displayName} The display name of the player assigned to the transaction (if applicable).
#'    \item \code{person.id} A unique numerical identifier for the player assigned to the transaction (if applicable).
#'    \item \code{pressure.squad.name} The name of the squad the pressure information is assigned to.
#'    \item \code{pressure.squad.id} A unique numerical identifier for the squad the pressure information is assigned to. 
#'    \item \code{pressure.squad.code} A short code to represent the squad the pressure information is assigned to.
#'    \item \code{pressure.name} The name of the type of pressure applied (ie. Set Position). 
#'    \item \code{pressure.code} A short code to represent the type of pressure applied.
#'    \item \code{pressure.points} The points value of the type of pressure applied.
#'    \item \code{pressure.fullname1} The fullname of the first pressure player.
#'    \item \code{pressure.displayname1} The display name of the first pressure player.
#'    \item \code{pressure.personid1} A unique numerical identifier for the first pressure player.
#'    \item \code{pressure.role1} The role number of the first pressure player (1).
#'    \item \code{pressure.fullname2} The fullname of the second pressure player.
#'    \item \code{pressure.displayname2} The display name of the second pressure player. 
#'    \item \code{pressure.personid2} A unique numerical identifier for the second pressure player.
#'    \item \code{pressure.role2} The role number of the second pressure player (2).
#'    \item \code{zone.physical} The zone in which the transaction takes place, relative to the physical ground.
#'    \item \code{zone.logical} The zone in which the transaction takes place, relative to the squad in possession.
#'    \item \code{location.x} The x coordinate of the transaction.
#'    \item \code{location.y} the y coordinate of the transaction.
#'    \item \code{location.x.std} The x coordinate of the transaction transformed to a standard ground dimension (160x141).
#'    \item \code{location.y.std} The y coordinate of the transaction transformed to a standard ground dimension (160x141).
#'    \item \code{location.rotated.x} The x coordinate of the transaction rotated to give all squads attacking left-to-right.
#'    \item \code{location.rotated.y} The y coordinate of the transaction rotated to give all squads attacking left-to-right.
#'    \item \code{location.rotated.x.std} The x coordinate of the transaction transformed to a standard ground dimension (160x141) & rotated to give all squads attacking left-to-right.
#'    \item \code{location.rotated.y.std} The y coordinate of the transaction transformed to a standard ground dimension (160x141) & rotated to give all squads attacking left-to-right.
#'    \item \code{kicking.foot} On kicking transactions, the foot of the kicking player.
#'    \item \code{kicking.intent} On kicking transactions, the intent of the kicking player.
#'    \item \code{kicking.distance} On kicking transactions, a description of the kicks distance.
#'    \item \code{kicking.direction} On kicking transactions, a description of the kicks direction.
#'    \item \code{inside50.direction} On inside 50 transactions, a description of the kicks direction.
#'    \item \code{inside50.intent} On inside 50 transactions, the intent of the kicking player.
#'    \item \code{shot.angle} A text description of the angle of the shot.
#'    \item \code{shot.distance} A text description of the distance of the shot.
#'    \item \code{shot.result} The result of the shot on goal (Does not include Goals).
#'    \item \code{shot.source} The source from which the shot on goal resulted (ie. General Play).
#'    \item \code{shot.type} The type of shot attempted (ie. General Play Snap).
#'    \item \code{freekick.context} On free kick transactions, the broad context from which the free kick was awarded.
#'    \item \code{freekick.reason} On free kick transactions, the specific reason the free kick was awarded.
#'    \item \code{kickin.direction} On kick in transactions, a text description of the direction taken from the kick in.
#'    \item \code{time.capture.UTC} The date and time of the event in UTC.
#'    \item \code{time.capture.flag} Boolean indicating if the timestamp was captured using time capture or calculated using period start utc and elapsed seconds.
#'}
#'@examples
#'getMatchTransactions(216085122)
#'@export
getMatchTransactions <- function(matchId,...){
  
  # Hit API for response
  rawResponse <- cdAPIresponse(endpoint = paste("matches", matchId,"transactions",sep = '/'), ...) 
  
  if(is.null(rawResponse)){
    return(rawResponse)
  } else {
    
    # Convert response to flat list
    listResponse <- rawResponse %>% resp_body_json(simplifyVector = TRUE)
    
    # Handle if successful response but no events happened yet (second element of list empty)
    if(is_empty(listResponse[[1]])) {
      returnData        <- data.frame(matrix(ncol = length(getMatchTransactionsExposedFields), nrow = 0))
      names(returnData) <- names(getMatchTransactionsExposedFields)
      message(paste0("\nWarning:\n--> 0 rows of data in response.")) 
      return(returnData)
      
      # Normal response, play on    
    } else {
      
      # Convert list into DF
      returnData <- listResponse %>% as.data.frame() %>% jsonlite::flatten()
      
      # strip 'transactions.' prefix
      names(returnData) <- gsub("^transactions\\.", "", names(returnData))
      
      # Get an index for each row attributed to a trx (for joining pressure info on only the first row)
      returnData$trx_n <- ave(seq_along(returnData$id), returnData$id, FUN = seq_along)
      
      #################
      # PRESSURE INFO #
      #################
      
      # Split out & handle pressure player info, join back to returnData
      if("pressure.players" %in% names(returnData)){
        
        # unnest & split out the pressure cols
        pressureData <- returnData[,c("id","pressure.players")] %>%  # need to retain 'id' here for join later
          tidyr::unnest_wider(., pressure.players, names_sep = "_")
        
        # Filter out all of rows that dont have pressure info (below lapply() wont work otherwise)
        pressureData = pressureData[!is.na(pressureData[[2]]),]
        
        # delimit each of the pressure cols (x==2 coniditional so that 'id' col only comes in once)
        pressureData <- lapply(2:5, function(x) {
          if(x==2) cbind(pressureData[, "id"],do.call(rbind, as.list(pressureData[[x]])))
          else cbind(do.call(rbind, as.list(pressureData[[x]])));
        })
        
        # Convert to DF
        pressureData = data.frame(pressureData)
        
        # This if/else will handle if there are *ONLY* 1-player pressure stats in the response OR if there are both 1&2 pressure stats, and handle accordingly
        if(dim(pressureData)[2]==5){
          names(pressureData)[2:5] <- getMatchTransactionsPressureCols1Player                                                                               # Rename with first pressure player colnames
          pressureData[getMatchTransactionsPressureCols2Player] <- lapply(getMatchTransactionsPressureCols2Player, function(x) rep(NA, nrow(pressureData))) # Add in second pressure player cols as NA
          pressureData$trx_n <- 1                                                                                                                           # Add in a trx_n column that = 1 so pressure info will only join to the first row of the given trx (if there are multiple rows for a single trx) // returnData has been set with a count for each row of each trx to join to
        } else {
          names(pressureData)[2:9] <- getMatchTransactionsPressureCols                            # 2nd pressure player stats exist so rename with full pressureCols vector
          singlePressureTrx <- pressureData$pressure.personid1 == pressureData$pressure.personid2 # Identifying rows where pressure.personid1 = pressure.personid2 (therefore only single pressure player TRX)
          pressureData[singlePressureTrx, getMatchTransactionsPressureCols2Player] <- NA          # Make second pressure player cols NA when only a single pressure player trx
          pressureData$trx_n <- 1                                                                 # Add in a trx_n column that = 1 so pressure info will only join to the first row of the given trx (if there are multiple rows for a single trx) // returnData has been set with a count for each row of each trx to join to
        }
        
        ########
        
        # Join the original data back on to the pressure info
        returnData <- left_join(returnData,pressureData, by = c("id","trx_n")) %>% dplyr::select(-"pressure.players",-"trx_n")
        
        # Turn pressure data into correct types
        returnData[getMatchTransactionsPressureCols[1:4]] <- lapply(returnData[getMatchTransactionsPressureCols[1:4]], as.character)
        returnData[getMatchTransactionsPressureCols[5:8]] <- lapply(returnData[getMatchTransactionsPressureCols[5:8]], as.integer)
        
      }
      
      #################
      
      # get vector of missing cols between whitelist and response
      missing <- setdiff(getMatchTransactionsExposedFields,names(returnData))
      
      # Add on any of the missing columns in the response 
      returnData[missing] <- lapply(missing, function(x) rep(NA, nrow(returnData)))
      
      # Select exposed fields (getMatchTransactionsExposedFields) & rename columns
      returnData        <- returnData[, getMatchTransactionsExposedFields]
      names(returnData) <- names(getMatchTransactionsExposedFields)
      
      return(returnData)
    }
  }
}

#'Match Entries
#'
#'Get a list of Inside 50 entries for a match.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of inside 50 entries for a match, with one row per entry. NULL if the match is yet to start.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{entry.trx.id} The transaction ID of the entry, used for ordering chronologically.
#'    \item \code{entry.period} The period of the entry.
#'    \item \code{entry.period.secs} The elapsed time within the period of the entry.
#'    \item \code{entry.player.id} A unique numerical identifier of the player responsible for the entry.
#'    \item \code{entry.player.fullname} The fullname of the player responsible for the entry. 
#'    \item \code{entry.player.display.name} The display name of the player responsible for the entry.
#'    \item \code{entry.squad.id} A numerical identifier of the squad player responsible for the entry belongs to. 
#'    \item \code{entry.squad.name} The name of the squad the player responsible for the entry belongs to. 
#'    \item \code{entry.squad.code} A short code to represent the squad the player responsible for the entry belongs to. 
#'    \item \code{entry.type} The type of inside 50 entry.
#'    \item \code{entry.source.name} The game situation relative to the origin of a team's possession that results in an entry.
#'    \item \code{entry.source.type} Inside 50 entries where direct indicates the first chain after the specified entry.source.name 
#'    
#'    - For centre bounce and midfield stoppage \code{entry.source.name}, direct indicates the entry was in the clearance chain \cr
#'    
#'    - For repeat \code{entry.source.name}, direct indicates the entry was on the first turnover chain after an opposition rebound 50 \cr
#'    
#'    - For transition \code{entry.source.name}, direct indicates the entry was in the same chain as the rebound 50
#'    \item \code{entry.kick.is.ground} For inside 50 entries that are kicks, was the entry from a ground kick (true/false).
#'    \item \code{entry.kick.foot} For inside 50 entries that are kicks, which foot did the kicking player use.
#'    \item \code{entry.kick.intent} For inside 50 entries that are kicks, the intent of the kicker. 
#'    \item \code{entry.kick.distance} For inside 50 entries that are kicks, the distance of the kick.
#'    \item \code{entry.kick.direction} For inside 50 entries that are kicks, the direction of the kick
#'    \item \code{entry.kick.launch.distance.to.goal} For inside 50 entries that are kicks, the straight line distance to goal from the launch point of the kick.
#'    \item \code{entry.kick.result.distance.to.goal} For inside 50 entries that are kicks, the straight line distance to goal from the result point of the kick.
#'    \item \code{entry.kick.pressure.name} For inside 50 entries that are kicks, the name of the type of pressure applied to the kicker.
#'    \item \code{entry.kick.pressure.code} For inside 50 entries that are kicks, a short code to describe the type of pressure applied to the kicker.
#'    \item \code{entry.kick.pressure.points} For inside 50 entries that are kicks, the number of points associated with the pressure type applied to the kicker.
#'    \item \code{entry.kick.launch.location.x} The x coordinate of the inside 50 launch location.
#'    \item \code{entry.kick.launch.location.y} The y coordinate of the inside 50 launch location.
#'    \item \code{entry.kick.launch.location.x.std} The x coordinate of the inside 50 launch location transformed to a standard ground dimension (160x141).
#'    \item \code{entry.kick.launch.location.y.std} The y coordinate of the inside 50 launch location transformed to a standard ground dimension (160x141).
#'    \item \code{entry.kick.launch.location.rotated.x} The x coordinate of the inside 50 launch location rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.launch.location.rotated.y} The y coordinate of the inside 50 launch location rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.launch.location.rotated.x.std} The x coordinate of the inside 50 launch location transformed to a standard ground dimension (160x141) & rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.launch.location.rotated.y.std} The x coordinate of the inside 50 launch location transformed to a standard ground dimension (160x141) & rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.result.location.x} The x coordinate of the inside 50 result location. 
#'    \item \code{entry.kick.result.location.y} The y coordinate of the inside 50 result location. 
#'    \item \code{entry.kick.result.location.x.std} The x coordinate of the inside 50 result location transformed to a standard ground dimension (160x141).
#'    \item \code{entry.kick.result.location.y.std} The y coordinate of the inside 50 result location transformed to a standard ground dimension (160x141).
#'    \item \code{entry.kick.result.location.rotated.x} The x coordinate of the inside 50 result location rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.result.location.rotated.y} The y coordinate of the inside 50 result location rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.result.location.rotated.x.std} The x coordinate of the inside 50 result location transformed to a standard ground dimension (160x141) & rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.result.location.rotated.y.std} The y coordinate of the inside 50 result location transformed to a standard ground dimension (160x141) & rotated to give all squads attacking left-to-right.
#'}
#'@examples
#'getEntries(216085122)
#'@export
getEntries <- function(matchId,...){
  # Hit API for response
  rawResponse <- cdAPIresponse(matchId,paste('matches',matchId,'entries',sep='/'),...)
  
  if(is.null(rawResponse)){
    return(rawResponse)
  } else {
    # Convert response to flat list
    listResponse <- rawResponse %>% resp_body_json(simplifyVector = TRUE)
    
    # Handle if successful response but no events happened yet (second element of list empty)
    if(is_empty(listResponse[[2]])) {
      returnData        <- data.frame(matrix(ncol = length(getEntriesWhitelist), nrow = 0))
      names(returnData) <- getEntriesWhitelist
      message(paste0("\nWarning:\n--> 0 rows of data in response.")) 
      return(returnData)
    } else {
      # Convert list into DF
      returnData <- listResponse %>% as.data.frame() %>% jsonlite::flatten()
      
      # Get vector of the missing fields (IF ANY) in the call info
      missing <- setdiff(getEntriesWhitelist,names(returnData))
      
      # Add on any of the missing columns in the response 
      returnData[missing] <- lapply(missing, function(x) rep(NA, nrow(returnData)))
    }
    
    # Select exposed fields (getEntriesExposedFields) & rename columns
    returnData        <- returnData[, getEntriesExposedFields]
    names(returnData) <- names(getEntriesExposedFields)
    
    return(returnData)
  }
} 

#'Match Squad Stats (POST Endpoint)
#'
#'Get squad stats for a match via a payload to the POST endpoint. 
#'@param matchId A unique numerical identifier of a match.
#'@param payload A nested list containing the parcels of data to be returned by the API. See: \code{createPayload()} as a method of simplifying this step.
#'   \describe{
#'     \item{\code{metricCodes (list)}}{ A list of the metric codes of the desired metrics (ie. \code{list("TACKLE","CHAIN_LAUNCH_CB_GB")})\cr 
#'     Default Behaviour: If no metric code(s) are specifically selected, will return ALL valid metrics.}
#'     
#'     \item{\code{periods (list)}}{ A list of the desired match periods (ie. \code{list(1,2,3,4)})\cr
#'     Default Behaviour: If no period(s) are specifically selected, will return data for the MATCH.}
#'     
#'     \item{\code{zones (list)}}{ A list of the desired zones (ie. \code{list("AM","D50")})\cr
#'     Default Behaviour: If no zones are specifically selected, will return data for ALL zones.}
#'     
#'     \item{\code{team (character)}}{ A code for which squad to return data for (Squad-Only Parameter) (ie. \code{"home"} or \code{"away"}\cr
#'     Default Behaviour: If no team is selected, will return data for BOTH teams}
#'     
#'     \item{\code{context (character)}}{ The context in which the data will be returned (Squadonly parameter) (ie. \code{"For"}, \code{"Against"}, \code{"diff"})\cr
#'     Default Behaviour: If no context is specifically selected, will return data in the 'For' context.}
#'     
#'     \item{\code{id (character)}}{ A usersettable identifier for the given payload, e.g. \code{"Q1_F50_Tackles"})\cr
#'     Default Behaviour: If no id is specifically passed in to a given payload list, the given list(s) will have their index in the payload order returned as an integer starting from 0.}
#'     
#'     \item{\code{lastXseconds (numeric)}}{ Limits statistics to counting events that occurred in the last X number of seconds (ie. lastXseconds = 300 will return data from the last 5 minutes)\cr
#'     Default Behaviour: If no lastXseconds value is specifically supplied, NO filter on match period seconds will be applied.}
#'     
#'     \item{\code{fromPeriodSeconds (numeric)}}{ Limits statistics to counting events from this point in the period/match (ie. fromPeriodSeconds = 300 will return data up to the first 5 minutes onwards)\cr
#'     Default Behaviour: If no fromPeriodSeconds value is specifically supplied, NO filter on match period seconds will be applied.}
#'     
#'     \item{\code{toPeriodSeconds (numeric)}}{ Limits statistics to counting events to this point in the period/match (ie. toPeriodSeconds = 300 will return data from the first 5 minutes onwards)\cr
#'     Default Behaviour: If no toPeriodSeconds value is specifically supplied, NO filter on match period seconds will be applied.}
#'   }
#'@param info A logical (\code{TRUE/FALSE}) to include the payload information alongside the data for each payload. Defaults to \code{FALSE}
#'@param verbose  A logical (\code{TRUE/FALSE}) indicating whether to enable verbose messaging to the console. When set to \code{TRUE}, the function will print additional information and progress messages to the console to provide a more detailed view of its execution. Defaults to \code{FALSE} for a quieter output.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of metrics supplied by the payload for each player in a match.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{stat.code} The metric code (ALL_CAPS format).
#'    \item \code{stat.name} The metric name (singular).
#'    \item \code{stat.plural} The metric name (plural).
#'    \item \code{value} The numeric metric value with no formatting applied.
#'    \item \code{display} The formatted metric value as a text string.
#'    \item \code{id} A unique identifier string able to be supplied by the user for each list in the payload. Defaults to numerical index starting at 0. 
#'    \item \code{info.metric.codes} (when \code{info = TRUE}) The metric code(s) supplied to the specific list in the payload for that row of data.
#'    \item \code{info.periods} (when \code{info = TRUE}) The period(s) supplied to the specific list in the payload for that row of data.
#'    \item \code{info.zones} (when \code{info = TRUE}) The zone(s) supplied to the specific list in the payload for that row of data.
#'    \item \code{info.team} (when \code{info = TRUE}) The team supplied to the specific list in the payload for that row of data.
#'    \item \code{info.context} (when \code{info = TRUE}) The match context supplied to the specific list in the payload for that row of data.
#'}
#'@examples
#'# Payload Example:
#'squadPOSTPayloadExample <- list(
#'  squadMetricRequests = list(
#'    list(
#'      metricCodes = list("TACKLE"),
#'      periods     = list(1),
#'      zones       = list("F50"),
#'      context     = "For",
#'      id          = "Q1_F50_Tackles"
#'    )
#'  )
#')
#'
#'# Function Run:
#'getSquadStatsPOST(matchId = 120390401, payload = squadPOSTPayloadExample, info = T, verbose = T)
#'@export
getSquadStatsPOST <- function(matchId, payload, info = FALSE, verbose = FALSE, ...){
  
  if(sub("MetricRequests", "", names(payload)) == "squad"){
    fieldsToCheck <- c("metricCodes", "team", "periods", "zones")
  } else {
    message("Incorrect payload passed to function:\n--> Have you provided a PLAYER payload to the SQUAD function?")
    return()
  } 
  
  # Using cdAPIPOSTresponse function to hit/retrieve response from POST API 
  rawResponse <- cdAPIPOSTresponse(matchId = matchId, endpoint = "squad", payload = payload, ...)
  
  if(is.null(rawResponse)){
    return(rawResponse)
  } else {
    
    if(verbose){
      payloadDefaults(payload)                                                                    # Check if payload full, communicate defaults
      message(paste0("\nSuccess [Status: ",rawResponse$status,"]\n--> POST request successful.")) # Communicate success
    }
    
    # Convert response to flat list
    listResponse <- rawResponse %>% resp_body_json(simplifyVector = TRUE)
    
    # Extract data out of listResponse
    returnData <- listResponse[[1]] %>% 
      tidyr::unnest("squads", names_sep = "_") %>%  
      filter(!(row_number() %in% which(sapply(.$squads_statistics,class)=="list"))) %>% 
      tidyr::unnest("squads_statistics", names_sep = "_")
    
    if(nrow(returnData) == 0) {
      returnData        <- data.frame(matrix(ncol = length(getSquadStatsPOSTExposedFields), nrow = 0))
      names(returnData) <- getSquadStatsPOSTExposedFields
      if(verbose) message(paste0("\nWarning:\n--> 0 rows of data for the payload supplied.")) 
      return()
    } else {
      returnData        <- returnData[, getSquadStatsPOSTExposedFields]
      names(returnData) <- names(getSquadStatsPOSTExposedFields)
    }
    
    # Include the information from the payload call in the output? (info = T/F)
    if(info){
      
      # Get vector of the missing fields in the call info
      missing <- setdiff(getSquadStatsPOST_info_Whitelist,names(listResponse[[2]][-which(names(listResponse[[2]]) == "id")]))
      
      # Extract info
      callInfo <- listResponse[[2]] %>%                              # [[2]] gives the player/squad metric requests included in the payload
        mutate_if(is.list, simplify_all) %>%                         # Flatten out (necessary)
        mutate(!!!setNames(rep(NA, length(missing)), missing)) %>%   # Create cols for any of the missing params
        mutate(metricCodes = ifelse(is.na(metricCodes) | metricCodes   == "NULL", "All Available" ,gsub("^c\\(|\\)$|\"", "", metricCodes)) , # This line handles if the given input wasnt supplied, and assigns a default value to go into the info
               periods     = ifelse(is.na(periods)     | periods       == "NULL", "Match" ,gsub("^c\\(|\\)$|\"", "", periods)) ,             # This line handles if the given input wasnt supplied, and assigns a default value to go into the info   
               team        = ifelse(is.na(team)        | team          == "NULL", "Both"  ,gsub("^c\\(|\\)$|\"", "", team)),                 # This line handles if the given input wasnt supplied, and assigns a default value to go into the info
               zones       = ifelse(is.na(zones)       | zones         == "NULL", "All"   ,gsub("^c\\(|\\)$|\"", "", zones)),                # This line handles if the given input wasnt supplied, and assigns a default value to go into the info
               context     = ifelse(is.na(context)     | context       == "NULL", "For"   ,gsub("^c\\(|\\)$|\"", "", context)) ,             # This line handles if the given input wasnt supplied, and assigns a default value to go into the info
               lastXSeconds= ifelse(is.na(lastXSeconds)| lastXSeconds  == "NULL", "All"   ,gsub("^c\\(|\\)$|\"", "", lastXSeconds)))         # This line handles if the given input wasnt supplied, and assigns a default value to go into the info
      
      # Select exposed fields (getPlayerStatsPOST_info_ExposedFields) & rename columns
      callInfo        <- callInfo[, getSquadStatsPOST_info_ExposedFields]
      names(callInfo) <- names(getSquadStatsPOST_info_ExposedFields)
      
      # Join info back to main data via 'id'
      returnData <- returnData %>% 
        left_join(.,callInfo,"id") %>% 
        relocate(id, .after = last_col())
      
    } else {
      returnData <- returnData %>%
        relocate(id, .after = last_col())
    }
    return(returnData)
  }
}

#'Match Player Stats (POST Endpoint)
#'
#'Get player stats for a match via a payload to the POST endpoint. 
#'@param matchId A unique numerical identifier of a match.
#'@param payload A nested list containing the parcels of data to be returned by the API. See: \code{createPayload()} as a method of simplifying this step.
#'   \describe{
#'     \item{\code{metricCodes (list)}}{ A list of the metric codes of the desired metrics (ie. \code{list("TACKLE","CHAIN_LAUNCH_CB_GB")})\cr 
#'     Default Behaviour: If no metric code(s) are specifically selected, will return ALL valid metrics.}
#'     
#'     \item{\code{periods (list)}}{ A list of the desired match periods (ie. \code{list(1,2,3,4)})\cr
#'     Default Behaviour: If no period(s) are specifically selected, will return data for the MATCH.}
#'     
#'     \item{\code{zones (list)}}{ A list of the desired zones (ie. \code{list("AM","D50")})\cr
#'     Default Behaviour: If no zones are specifically selected, will return data for ALL zones.}
#'     
#'     \item{\code{context (character)}}{ The context in which the data will be returned (Squadonly parameter) (ie. \code{"For"}, \code{"Against"}, \code{"diff"})\cr
#'     Default Behaviour: If no context is specifically selected, will return data in the 'For' context.}
#'     
#'     \item{\code{id (character)}}{ A usersettable identifier for the given payload, e.g. \code{"Q1_F50_Tackles"})\cr
#'     Default Behaviour: If no id is specifically passed in to a given payload list, the given list(s) will have their index in the payload order returned as an integer starting from 0.}
#'     
#'     \item{\code{lastXseconds (numeric)}}{ Limits statistics to counting events that occurred in the last X number of seconds (ie. lastXseconds = 300 will return data from the last 5 minutes)\cr
#'     Default Behaviour: If no lastXseconds value is specifically supplied, NO filter on match period seconds will be applied.}
#'     
#'     \item{\code{fromPeriodSeconds (numeric)}}{ Limits statistics to counting events from this point in the period/match (ie. fromPeriodSeconds = 300 will return data up to the first 5 minutes onwards)\cr
#'     Default Behaviour: If no fromPeriodSeconds value is specifically supplied, NO filter on match period seconds will be applied.}
#'     
#'     \item{\code{toPeriodSeconds (numeric)}}{ Limits statistics to counting events to this point in the period/match (ie. toPeriodSeconds = 300 will return data from the first 5 minutes onwards)\cr
#'     Default Behaviour: If no toPeriodSeconds value is specifically supplied, NO filter on match period seconds will be applied.}
#'   }
#'@param info A logical (\code{TRUE/FALSE}) to include the payload information alongside the data for each payload. Defaults to \code{FALSE}
#'@param verbose  A logical (\code{TRUE/FALSE}) indicating whether to enable verbose messaging to the console. When set to \code{TRUE}, the function will print additional information and progress messages to the console to provide a more detailed view of its execution. Defaults to \code{FALSE} for a quieter output.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of metrics supplied by the payload for each player in a match.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{player.name} The full name of the player.
#'    \item \code{player.display} The display name of the player, represented as first initial and surname.
#'    \item \code{player.id} A unique numerical identifier of the player.
#'    \item \code{stat.code} The metric code (ALL_CAPS format).
#'    \item \code{stat.name} The metric name (singular).
#'    \item \code{stat.plural} The metric name (plural).
#'    \item \code{value} The numeric metric value with no formatting applied.
#'    \item \code{display} The formatted metric value as a text string.
#'    \item \code{id} A unique identifier string able to be supplied by the user for each list in the payload. Defaults to numerical index starting at 0. 
#'    \item \code{info.metric.codes} (when \code{info = TRUE}) The metric code(s) supplied to the specific list in the payload for that row of data.
#'    \item \code{info.periods} (when \code{info = TRUE}) The period(s) supplied to the specific list in the payload for that row of data.
#'    \item \code{info.zones} (when \code{info = TRUE}) The zone(s) supplied to the specific list in the payload for that row of data.
#'    \item \code{info.team} (when \code{info = TRUE}) The team supplied to the specific list in the payload for that row of data.
#'    \item \code{info.context} (when \code{info = TRUE}) The match context supplied to the specific list in the payload for that row of data.
#'}
#'@examples
#'# Payload Example:
#'playerPOSTPayloadExample <- list(
#'  playerMetricRequests = list(
#'    list(
#'      metricCodes = list("KICK", "MARK", "HANDBALL", "GOAL"),
#'      periods     = list(),
#'      zones       = list(),
#'      team        = "home" ,
#'      id          = "homeTeam (kick,mark,handball,goal)"
#'    )
#'   )
#' )
#'
#'# Function Run:
#'getPlayerStatsPOST(matchId = 120390401, payload = playerPOSTPayloadExample, info = T, verbose = T)
#'@export
getPlayerStatsPOST <- function(matchId, payload, info = FALSE, verbose = FALSE, ...){
  
  if(sub("MetricRequests", "", names(payload)) == "player"){
    fieldsToCheck <- c("metricCodes", "team", "periods", "zones")
  } else {
    message("Incorrect payload passed to function:\n--> Have you provided a SQUAD payload to the PLAYER function?")
    return()
  } 
  
  # Using cdAPIPOSTresponse function to hit/retrieve response from POST API 
  rawResponse <- cdAPIPOSTresponse(matchId = matchId, endpoint = "player", payload = payload, ...)
  
  if(is.null(rawResponse)){
    return(rawResponse)
  } else {  
    
    if(verbose){
      payloadDefaults(payload)                                                                    # Check if payload full, communicate defaults
      message(paste0("\nSuccess [Status: ",rawResponse$status,"]\n--> POST request successful.")) # Communicate success
    }
    
    # Convert response to flat list
    listResponse <- rawResponse %>% resp_body_json(simplifyVector = TRUE)
    
    # Unnest down to players
    returnData <- listResponse[[1]] %>% 
      tidyr::unnest("squads", names_sep = "_") %>%  
      tidyr::unnest("squads_players")
    
    # Get vector of indexes of type list in statistics
    listRows <- which(sapply(returnData$statistics,class)=="list")
    
    # Extract data out of listResponse
    returnData <- returnData %>%
      filter(!(row_number() %in% listRows)) %>% # If any rows are of class list - remove them before unnesting below (will generate error)
      tidyr::unnest("statistics", names_sep = "_")
    
    # Handle if successful response but payload specified has returned no data
    if(nrow(returnData) == 0) {
      returnData        <- data.frame(matrix(ncol = length(getPlayerStatsPOSTExposedFields), nrow = 0))
      names(returnData) <- getPlayerStatsPOSTExposedFields
      if(verbose) message(paste0("\nWarning:\n--> 0 rows of data for the payload supplied.")) 
      return()
    } else {
      returnData        <- returnData[, getPlayerStatsPOSTExposedFields]
      names(returnData) <- names(getPlayerStatsPOSTExposedFields)
    }
    
    # Include the information from the payload call in the output? (info = T/F)
    if(info){
      
      # Get vector of the missing fields in the call info (excluding 'id')
      missing <- setdiff(getPlayerStatsPOST_info_Whitelist,names(listResponse[[2]][-which(names(listResponse[[2]]) == "id")]))
      
      # Extract info
      callInfo <- listResponse[[2]] %>%                              # [[2]] gives the player/squad metric requests included in the payload
        mutate_if(is.list, simplify_all) %>%                         # Flatten out (necessary)
        mutate(!!!setNames(rep(NA, length(missing)), missing)) %>%   # Create cols for any of the missing params
        mutate(metricCodes = ifelse(is.na(metricCodes) | metricCodes   == "NULL", "All Available" ,gsub("^c\\(|\\)$|\"", "", metricCodes)) , # This line handles if the given input wasnt supplied, and assigns a default value to go into the info
               periods     = ifelse(is.na(periods)     | periods       == "NULL", "Match" ,gsub("^c\\(|\\)$|\"", "", periods)) ,             # This line handles if the given input wasnt supplied, and assigns a default value to go into the info   
               team        = ifelse(is.na(team)        | team          == "NULL", "Both"  ,gsub("^c\\(|\\)$|\"", "", team)),                 # This line handles if the given input wasnt supplied, and assigns a default value to go into the info
               zones       = ifelse(is.na(zones)       | zones         == "NULL", "All"   ,gsub("^c\\(|\\)$|\"", "", zones)),                # This line handles if the given input wasnt supplied, and assigns a default value to go into the info
               lastXSeconds= ifelse(is.na(lastXSeconds)| lastXSeconds  == "NULL", "All"   ,gsub("^c\\(|\\)$|\"", "", lastXSeconds)))         # This line handles if the given input wasnt supplied, and assigns a default value to go into the info
      
      # Select exposed fields (getPlayerStatsPOST_info_ExposedFields) & rename columns
      callInfo        <- callInfo[, getPlayerStatsPOST_info_ExposedFields]
      names(callInfo) <- names(getPlayerStatsPOST_info_ExposedFields)
      
      # Join info back to main data via 'id'
      returnData <- returnData %>% 
        left_join(.,callInfo,"id") %>% 
        relocate(id, .after = last_col())
      
    } else {
      # Remove the joinId if info not required
      returnData <- returnData %>%
        relocate(id, .after = last_col())
    }
    return(returnData)
  } 
}

#'AFL Club Feed Transaction File
#'
#'Get the AFL Club Trx Feed file formerly available via the support site.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame in the same format and structure as the AFL Club Transaction Feed file formerly available via the support site.
#' \itemize{
#'    \item \code{MATCH_ID} A unique numerical identifier of a match.
#'    \item \code{MATCH_DATE}The calendar date of a match in local time.
#'    \item \code{MATCH_TIME} The local start time of a match.
#'    \item \code{SEASON_ID} A numerical identifier of a season.
#'    \item \code{GROUP_ROUND_NO} The round number of the match. Continues to count up during finals.
#'    \item \code{VENUE_NAME} The name of the match venue.
#'    \item \code{HOME_SQUAD} The name of the home squad.
#'    \item \code{HOME_SCORE} The score of the home squad.
#'    \item \code{AWAY_SQUAD} The name of the away squad.
#'    \item \code{AWAY_SCORE} The score of the away squad.
#'    \item \code{MATCH_TRX_ID} A unique numerical identifier for a given transaction, used for ordering chronologically.
#'    \item \code{SEQUENCE} Unique identifier of events within a single transaction. Used for multi-player transactions.
#'    \item \code{PERIOD} The period (quarter) of the match.
#'    \item \code{PERIOD_SECS} The elapsed time in seconds for live periods, or the period length for completed periods.
#'    \item \code{STATISTIC_CODE} The statistic code for a given transaction.
#'    \item \code{PERSON_ID} A unique numerical identifier for the player assigned to the transaction (if applicable).
#'    \item \code{FULLNAME} The fullname of the player assigned to the transaction (if applicable).
#'    \item \code{SQUAD_NAME} The name of the squad assigned to the transaction.
#'    \item \code{OPP_SQUAD} The opposing squad to the one assigned to the transaction.
#'    \item \code{AR_ID} Away Ruck PERSON_ID (if applicable).
#'    \item \code{AR} Away Ruck FULLNAME (if applicable).
#'    \item \code{H1_ID} Home Midfielder 1 PERSON_ID (if applicable).
#'    \item \code{H1} Home Midfielder 1 FULLNAME (if applicable).
#'    \item \code{H2_ID} Home Midfielder 2 PERSON_ID (if applicable).
#'    \item \code{H2} Home Midfielder 2 FULLNAME (if applicable).
#'    \item \code{H3_ID} Home Midfielder 3 PERSON_ID (if applicable).
#'    \item \code{H3} Home Midfielder 3 FULLNAME (if applicable).
#'    \item \code{A1_ID} Away Midfielder 1 PERSON_ID (if applicable).
#'    \item \code{A1} Away Midfielder 1 FULLNAME (if applicable).
#'    \item \code{A2_ID} Away Midfielder 2 PERSON_ID (if applicable).
#'    \item \code{A2} Away Midfielder 2 FULLNAME (if applicable).
#'    \item \code{A3_ID} Away Midfielder 3 FULLNAME (if applicable).
#'    \item \code{A3} Away Midfielder 3 FULLNAME (if applicable).
#'    \item \code{ZONE_LOGICAL_AFL} The zone in which the transaction takes place, relative to the squad in possession.
#'    \item \code{ZONE_PHYSICAL_AFL} The zone in which the transaction takes place, relative to the physical ground.
#'    \item \code{TRUEX} The x coordinate of the transaction.
#'    \item \code{TRUEY} The y coordinate of the transaction.
#'    \item \code{VENUE_LENGTH} The length of the venue in metres.
#'    \item \code{VENUE_WIDTH} The width of the venue in metres.
#'    \item \code{STDX} The x coordinate of the transaction transformed to a standard ground dimension (160x141).
#'    \item \code{STDY} The y coordinate of the transaction transformed to a standard ground dimension (160x141).
#'    \item \code{XY_FLIP}
#'    \item \code{INITIAL_TRX_ID} The transaction ID of the start of the chain.
#'    \item \code{FINAL_TRX_ID} The transaction ID of the end of the chain.
#'    \item \code{CHAIN_SQUAD} The name of the squad in possession during the chain.
#'    \item \code{INITIAL_STATE} The starting state of the chain.
#'    \item \code{FINAL_STATE} The final state of the chain.
#'    \item \code{ZONE_LOGICAL_INITIAL} The zone in which the first transaction of the chain takes place, relative to the squad in possession.
#'    \item \code{FINAL_ZONE_LOGICAL} The zone in which the final transaction of the chain takes place, relative to the squad in possession.
#'    \item \code{LAUNCH_PERSON_ID} A unique numerical identifier of the player who launched the chain.
#'    \item \code{LAUNCH_PLAYER} The full name of the player who launched the chain.
#'    \item \code{GUILTY_PERSON_ID} Turnover player PERSON_ID (if applicable).
#'    \item \code{GUILTY_PLAYER} Turnover player FULLNAME (if applicable).
#'    \item \code{PARAM1} Additional captured parameters on transactions, showing the Shot Source, Free Kick Reason, Inside 50 Side or Kick In Direction
#'    \item \code{PARAM2} Additional captured parameters on transactions, showing the Shot Type, Free Kick Context or Inside 50 Type
#'    \item \code{PARAM3} Additional captured parameters on transactions, showing the Shot Angle
#'    \item \code{PARAM4} Additional captured parameters on transactions, showing the Shot Distance
#'    \item \code{KICK_FOOT} On kicking transactions, the foot of the kicking player.
#'    \item \code{KICK_INTENT} On kicking transactions, the intent of the kicking player.
#'    \item \code{KICK_DISTANCE} On kicking transactions, a description of the kicks distance.
#'    \item \code{KICK_DIRECTION} On kicking transactions, a description of the kicks direction.
#'    \item \code{PRESSURE_LEVEL} The name of the type of pressure applied (ie. Set Position).
#'    \item \code{PRESSURE_PLAYER_ID} A unique numerical identifier for the first pressure player.
#'    \item \code{PRESSURE_PLAYER} The fullname of the first pressure player.
#'    \item \code{PRESSURE_PLAYER2_ID} A unique numerical identifier for the second pressure player.
#'    \item \code{PRESSURE_PLAYER2} The fullname of the second pressure player.
#'    \item \code{PRESSURE_POINTS} The points value of the type of pressure applied.
#'}
#'@examples
#'getAFLClubTrxFeed(matchId = 120390401)
#'@export
getAFLClubTrxFeed <- function(matchId,...) {
  
  # Transactions
  basetrx      <- catchErrorMessage("Transactions Data", "getMatchTransactions", matchId, ...)
  # Chains
  chains       <- catchErrorMessage("Chains Data", "getChains", matchId, ...)
  # Match metadata
  matchDetails <- catchErrorMessage("Match Metadata", "getMatch", matchId, ...)
  # Venue metadata
  venueDetails <- catchErrorMessage("Venue Metadata", "getVenue", matchId, ...)
  
  # Put objects from required calls above into list
  objectList <- list("Transactions"=basetrx,"Chains"=chains,"Match Details"=matchDetails,"Venue Details"=venueDetails)
  
  # If any of the attempts to fetch data throw errors, print errors and escape 
  if(any(sapply(objectList,is.character))){
    message(paste0("Error building transaction file:\n",paste("-->",unlist(objectList[sapply(objectList,is.character)]),collapse="\n")))
    return(NULL)
  } else {
    
    # Home/Away Names & ID's - Placed here because we know all fetches from data are valid
    homeSquad  <-matchDetails$home.name
    awaySquad  <-matchDetails$away.name
    homeSquadId<-matchDetails$home.id
    awaySquadId<-matchDetails$away.id
    
    # Assign initial stoppage transactions to the home squad, and for ball ups and throw ins, assign the logical zone for each squad based on the physical zone of the stoppage
    # Remove hitout and shark transactions as they are better represented by their derived transactions
    basetrx <- basetrx %>%
      mutate(squad.name   = ifelse(stat.code %in% c('CEBO','THIN','BUTU','CETU'),homeSquad,squad.name),
             squad.id     = ifelse(stat.code %in% c('CEBO','THIN','BUTU','CETU'),homeSquadId,squad.id),
             zone.logical = ifelse(stat.code %in% c('THIN','BUTU'),zoneMapping(matchDetails$coin.toss.winning.squad.id, matchDetails$coin.toss.direction.decision, squad.id,period,zone.physical),zone.logical)) %>% # For all stoppages, assign the home squad to the transaction
      filter(!stat.code %in% c('HITOUT','SHARK'))                                                                                                                                                                    # Filter out hitouts as they are not present in the trxFiles
    
    # Get chains for the match, rename columns according the columns in the trxFile
    chains        <- chains[,getTRXfile_chainsFields]
    names(chains) <- names(getTRXfile_chainsFields)
    
    # Create a duplicate stoppage transaction with the away squad assigned to match business logic in trxFile
    stoppages <- basetrx %>%
      filter(stat.code %in% c('CEBO','THIN','BUTU','CETU')) %>%
      mutate(squad.name = awaySquad,
             squad.id = awaySquadId,
             zone.logical = ifelse(stat.code %in% c('THIN','BUTU'), zoneMapping(matchDetails$coin.toss.winning.squad.id, matchDetails$coin.toss.direction.decision, squad.id,period,zone.physical),zone.logical))
    
    # Create trxFile transactions and add 'sequence', which gives additional identifier to those transactions that have multiple players on it.
    enhancedtrx <- basetrx %>%
      rbind(stoppages) %>%
      group_by(trx.id, squad.id) %>%
      mutate(sequence1 = row_number()) %>%
      arrange(trx.id, sequence1) %>%
      group_by(trx.id) %>%
      mutate(sequence = row_number()) %>%
      arrange(trx.id, sequence)
    
    # Filter out the ruck transactions and assess if any have only one ruckman assigned (should have both)
    twoplayerstatsbase <- enhancedtrx %>%
      filter(stat.code %in% c('CBVS','TIVS','BUVS')) %>%
      group_by(match.id,trx.id) %>%
      mutate(count = n(),
             home_squad_n = length(squad.name[squad.name == homeSquad]),
             away_squad_n = length(squad.name[squad.name == awaySquad]),
             sequence = ifelse(count==1 & home_squad_n ==0,2,ifelse(count==1 & away_squad_n == 0, 1,sequence))
      )
    
    # Dataset of 'dummy' rows which will contain the rows to be added in cases where there is only one ruckman present in a ruck transaction ('CBVS','TIVS','BUVS')
    dummytwoplayerstats <- twoplayerstatsbase  %>%
      filter(count==1) %>%
      mutate(sequence = ifelse(count==1 & home_squad_n ==0,1,ifelse(count==1 & away_squad_n == 0, 2,sequence)),
             person.id = NA,
             person.fullname = NA)
    
    # If twoplayerstatsbase is empty ('CBVS','TIVS','BUVS' arent present) create an empty dataframe with the same names AND(!) class types
    if(nrow(twoplayerstatsbase)==0){
      twoplayerstats <- twoplayerstats_empty
      
      # If there has been cases of ruck contests with only one ruckman, bind on df (dummytwoplayerstats) containing dummy rows for the ruckman not present
    }else if(nrow(dummytwoplayerstats)!=0){
      twoplayerstats<-twoplayerstatsbase %>%
        rbind(dummytwoplayerstats) %>%
        arrange(trx.id, sequence) %>%
        dplyr::select(match.id,trx.id,stat.code, sequence, person.fullname, person.id) %>%
        pivot_wider(names_from = sequence, values_from = c(person.id, person.fullname))
      # Handle normally
    } else {
      twoplayerstats<-twoplayerstatsbase %>%
        arrange(trx.id, sequence) %>%
        dplyr::select(match.id,trx.id,stat.code, sequence, person.fullname, person.id) %>%
        pivot_wider(names_from = sequence, values_from = c(person.id, person.fullname))
    }
    
    # Reorder and rename the columns
    twoplayerstats        <- twoplayerstats[,getTRXfile_twoPlayerStats]
    names(twoplayerstats) <- names(getTRXfile_twoPlayerStats)
    
    #For transactions that end the chain without another chain, change the transaction id to allow the final transaction to be included in the chain
    #data manipulation to bring all seperated parameters into the same columns (PARAM)
    #logic to assign certain transactions and chains to the CB zone
    returnData <- matchDetails %>%
      left_join(enhancedtrx   , by = 'match.id') %>%
      left_join(twoplayerstats, by = c('match.id','trx.id','stat.code','person.id')) %>%
      left_join(venueDetails  , by = 'match.id') %>%
      mutate(join_trx = ifelse(stat.code %in% c('OOBO','BUCA','BEHI','GOAL','PEREN','RUSH','FRAG','OOFUK'),trx.id-1, trx.id)) %>%
      left_join(chains, join_by(trx.id >= INITIAL_TRX_ID,  join_trx<FINAL_TRX_ID, match.id == match.id)) %>%
      mutate(opp.squad.name       = ifelse(squad.name == homeSquad,awaySquad,homeSquad),
             PARAM1               = ifelse(!is.na(inside50.direction),inside50.direction,ifelse(!is.na(shot.source), shot.source,ifelse(!is.na(kickin.direction),kickin.direction,freekick.reason))),  # Business logic for PARAM1 in returnData
             PARAM1               = ifelse(stat.code %in% c('KISE','KIBI','KICL','KIIN','KILO','KISH','KIKIN','KIEF') & PARAM1 == 'Centre','Corridor',PARAM1),
             PARAM2               = ifelse(!is.na(inside50.intent),inside50.intent,ifelse(!is.na(shot.type), shot.type,freekick.context)),                                                             # Business logic for PARAM2 in trxFile
             PARAM3               = shot.angle,
             PARAM4               = shot.distance,
             XY_FLIP              = ifelse(coin.toss.winning.squad.id == homeSquadId,1,-1) * ifelse(is.na(coin.toss.winning.squad.id),1,-1) * ifelse(period %in% c(1,3,5),1,-1),
             match.date           = format(as.Date(match.date), "%d-%b-%y"),
             zone.logical         = ifelse(stat.code %in% c('CBCL','CBFP','CBHAD','CBHO','CBHSK','CEBO','CETU','CBHSD'), 'CB',ifelse(is.na(zone.logical),'U',zone.logical)),                           # For centre bounce type transations, assign to 'CB' zone
             INITIAL_STATE        = ifelse(INITIAL_STATE == 'INT','PG',INITIAL_STATE), ##change name of INT to PG to match trxFile
             ZONE_LOGICAL_INITIAL = ifelse(INITIAL_STATE == 'CB' & is.na(ZONE_LOGICAL_INITIAL),'CB',ZONE_LOGICAL_INITIAL),
             zone.physical        = ifelse(stat.code %in% c('MTCHI','PERST','PEREN','MTCHE'), 'M',zone.physical),
             pressure.name        = ifelse(pressure.name == 'Set Position','Set',ifelse(pressure.name == 'No Pressure','None',pressure.name)),                                                         # Change name to match trxFile
             FINAL_STATE          = ifelse(FINAL_STATE == 'RB','RUSH',FINAL_STATE)
      ) %>%
      arrange()
    
    # Filter down TRX file fields & apply renaming
    returnData        <- returnData[,getTRXfileExposedFields]
    names(returnData) <- names(getTRXfileExposedFields)
    
    # Param Mapping
    returnData$PARAM1 <- PARAM1_mapping[returnData$PARAM1]
    returnData$PARAM2 <- PARAM2_mapping[returnData$PARAM2]
    returnData$PARAM3 <- PARAM3_mapping[returnData$PARAM3]
    returnData$PARAM4 <- PARAM4_mapping[returnData$PARAM4]
    
    # return
    return(returnData)
  }
}

#'AFL Squad Summary File
#'
#'Get the AFL Squad Summary File formerly available via the support site.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame in the same format and structure as the AFL Squad Summary File formerly available via the support site.
#' \itemize{
#'    \item \code{MATCH_ID} A unique numerical identifier of a match.
#'    \item \code{SEASON_ID} A numerical identifier of a season.
#'    \item \code{GROUP_ROUND_NO} The round number of the match. Continues to count up during finals.
#'    \item \code{VENUE_NAME} The name of the match venue.
#'    \item \code{SQUAD_NAME} The name of the squad for the given row.
#'    \item \code{OPP_SQUAD_NAME} The name of the opposition squad for the given row.
#'    \item \code{SQUAD_MARGIN} The final margin of the match in relation to the team listed under SQUAD_NAME.
#'    \item \code{MARGIN} The margin at the end of the given period in relation to the team listed under SQUAD_NAME.
#'    \item \code{ZONE_LOGICAL_AFL} The zone in which the values within metrics that follow are belonging to, relative to the squad listed under SQUAD_NAME.
#'}
#'@examples
#'getSquadSummaryFile(matchId = 120390401)
#'@export
getSquadSummaryFile <- function(matchId,...) {
  
  # Hitting API for metadata
  rawResponse       <- cdAPIresponse(endpoint = paste('matches',matchId,sep='/'),...)
  if(is.null(rawResponse)) return(NULL); listResponse <- rawResponse %>% resp_body_json(simplifyVector = TRUE)
  matchDetails      <- as.data.frame(cbind(listResponse,listResponse$periods))[,matchDetailsCols]
  matchPeriodScores <- getPeriodScores(matchId)[,c("period","home.id","away.id","home.margin","away.margin")]
  
  # AFL Mens Check
  if(!isAFL(matchDetails$leagueId[1])) {
    message("Error:\n--> The matchId passed to getSquadSummaryFile() is not an AFL Mens match.")
    return(NULL)
  }
  
  # List of periods to iterate over
  maxPeriod        <- if(max(matchDetails$period)>4) max(matchDetails$period) else max(matchDetails$period); 
  matchPeriodsList <- as.list(1:maxPeriod) 
  
  # Not sure this is efficient but see how the below are being used
  Squads  <- data.frame("SQUAD_ID" = c(matchDetails$home.id[1], matchDetails$away.id[1]))
  periods <- data.frame("PERIOD"   = c(1:maxPeriod))
  zones   <- data.frame("ZONE_LOGICAL_AFL"= c('D50','DM','AM','F50','X')) 
  
  # Remove and instantiate inside package - rename as player/squad versions
  zonedMetricStrings         <- paste("list(", paste0('"',zonedMetrics_PlatformNames_Squad,'"', collapse = ','),")")
  zonelessMetricStrings      <- paste("list(", paste0('"',zonelessMetrics_PlatformNames_Squad,'"',  collapse = ','),")")
  zonelessMetricOtherStrings <- paste("list(", paste0('"',zonelessMetricsOther_PlatformNames_Squad,'"',  collapse = ','),")")
  
  # Use lapply to build a payload for each quarter as defined by matchPeriodList
  squadSummaryFilePayload <- lapply(matchPeriodsList, function(period) {
    payload <- list(
      squadMetricRequests = list(
        list(
          metricCodes = eval(parse(text=zonedMetricStrings)),
          team = NA,
          periods = list(period),
          zones = list("D50") , 
          id = "D50"
        ),
        list(
          metricCodes = eval(parse(text=zonedMetricStrings)),
          team = NA,
          periods = list(period),
          zones = list("DM") , 
          id = "DM"
        ),
        list(
          metricCodes = eval(parse(text=zonedMetricStrings)),
          team = NA,
          periods = list(period),
          zones = list("AM"),
          id = "AM"
        ),
        list(
          metricCodes = eval(parse(text=zonedMetricStrings)),
          team = NA,
          periods = list(period),
          zones = list("F50"),
          id = "F50"
        ),
        list(
          metricCodes = eval(parse(text=zonelessMetricStrings)),   ####metrics in X zone with no zone filter on this part of the call
          team = NA,
          periods = list(period),    # zoneless and ones that exist in both
          zones = NA,
          id="X"
        ),
        list(
          metricCodes = eval(parse(text=zonelessMetricOtherStrings)),  #### getting time in possession opposition
          team = NA,
          periods = list(period),
          context = "Against",
          zones = NA,
          id="Against"
        ),
        list(
          metricCodes = eval(parse(text=zonelessMetricOtherStrings)), #### getting time in possession diff
          team = NA,
          periods = list(period),
          context = "Diff",
          zones = NA,
          id="Diff"
        )
      )
    )
  })
  
  # Use post endpoint function to hit 
  apiSquadSummaryFile <- do.call(rbind, lapply(unlist(matchPeriodsList), function(x) {
    as.data.frame(getSquadStatsPOST(matchId = matchId, payload = squadSummaryFilePayload[[x]], info = TRUE))
  }))[c("squad.id", "info.periods", "id", "stat.code", "value")]
  
  # Create a 'PERIOD_LENGTH' metric, for each squad each period (this takes the same format as other metrics in the summary file but itsnt itself a metric)
  periodLength <- tidyr::expand_grid("squad.id" = Squads[[1]],matchDetails[,c("period","periodSecs")],"id"="X","stat.code"="PERIOD_LENGTH")
  names(periodLength)[names(periodLength) == "period"] <- "info.periods"
  names(periodLength)[names(periodLength) == "periodSecs"]   <- "value"
  periodLength <- periodLength[c("squad.id", "info.periods", "id", "stat.code", "value")]
  
  # Bind the Metrics from the API to the PERIOD_LENGTH df we've made a metric
  apiSquadSummaryFile              <- rbind(apiSquadSummaryFile, periodLength)
  apiSquadSummaryFile$info.periods <- as.numeric(apiSquadSummaryFile$info.periods)
  
  # Change Time In Possession names
  apiSquadSummaryFile$stat.code[which(apiSquadSummaryFile$stat.code == 'TIME_IN_POSSESSION' & apiSquadSummaryFile$id == 'Against')] <- "TIME_IN_POSS_OPP_SQUAD"
  apiSquadSummaryFile$stat.code[which(apiSquadSummaryFile$stat.code == 'TIME_IN_POSSESSION' & apiSquadSummaryFile$id == 'Diff')]    <- "TIME_IN_POSS_DIFF"
  
  # 
  apiSquadSummaryFile$id[which(apiSquadSummaryFile$id %in% c('Diff','Against'))] <- "X"
  
  ####create a empty dataframe that is: all SF metrics wide, by zones, by periods
  empty <- tidyr::expand_grid(squadSummaryFile_lookup, periods, zones, Squads)
  empty$PLATFORM_METRIC_CODE[which(empty$SF_METRIC_CODE == 'TIME_IN_POSS_OPP_SQUAD')] <- "TIME_IN_POSS_OPP_SQUAD"
  empty$PLATFORM_METRIC_CODE[which(empty$SF_METRIC_CODE == 'TIME_IN_POSS_DIFF')]      <- "TIME_IN_POSS_DIFF"
  
  # Turn from long to wide
  # Logic in here gets all the metrics that exist in both the X zone and in other zones and grabs:
  # - the response without a zone filter and then subtracts each of the zone responses of the same metric to get the metrics assigned to the 'M' zone
  
  ###join api response to empty data frame, joining by metric, zone, period and squad
  returnData <- empty %>%
    left_join(apiSquadSummaryFile,
              by = c("PLATFORM_METRIC_CODE" = "stat.code",
                     "ZONE_LOGICAL_AFL"     = "id",
                     "PERIOD"               = "info.periods",
                     "SQUAD_ID"             = "squad.id")) 
  
  # Make NA's 0 here before pivoting
  returnData$value[is.na(returnData$value)] <- 0
  
  # Round specific groups of metrics to either 0 or 1 decimal place 
  returnData$value<- ifelse(returnData$PLATFORM_METRIC_CODE %in% squadSummaryFile_roundedMetrics1DP,round(returnData$value,1),returnData$value)
  returnData$value<- ifelse(returnData$PLATFORM_METRIC_CODE %in% squadSummaryFile_roundedMetrics0DP,round(returnData$value,0),returnData$value)
  
  # Do arithmetic
  returnData <- returnData %>% 
    dplyr::select(-PLATFORM_METRIC_CODE)%>%
    pivot_wider(names_from = SF_METRIC_CODE, values_from = value) %>%
    group_by(PERIOD, SQUAD_ID) %>%
    mutate(
      CHAIN_METRES_ALL_ZONE              = sum(CHAIN_METRES[ZONE_LOGICAL_AFL != 'X']),
      CHAIN_METRES_NET_ALL_ZONE          = sum(CHAIN_METRES_NET[ZONE_LOGICAL_AFL != 'X']),
      CHAIN_METRES_NET_ST_ALL_ZONE       = sum(CHAIN_METRES_NET_ST[ZONE_LOGICAL_AFL != 'X']),
      CHAIN_METRES_REPLY_ALL_ZONE        = sum(CHAIN_METRES_REPLY[ZONE_LOGICAL_AFL != 'X']),
      CHAIN_METRES_REPLY_ST_ALL_ZONE     = sum(CHAIN_METRES_REPLY_ST[ZONE_LOGICAL_AFL != 'X']),
      CHAIN_METRES_ST_ALL_ZONE           = sum(CHAIN_METRES_ST[ZONE_LOGICAL_AFL != 'X']),
      FIRST_POSSESSION_TO_CLEAR_ALL_ZONE = sum(FIRST_POSSESSION_TO_CLEAR[ZONE_LOGICAL_AFL != 'X']),
      FIRST_POSSESSION_ALL_ZONE          = sum(FIRST_POSSESSION[ZONE_LOGICAL_AFL != 'X']),
      CLEARANCE_ALL_ZONE                 = sum(CLEARANCE[ZONE_LOGICAL_AFL != 'X']),
      STOPPAGE_ALL_ZONE                  = sum(STOPPAGE[ZONE_LOGICAL_AFL != 'X']),
      HITOUT_ALL_ZONE                    = sum(HITOUT[ZONE_LOGICAL_AFL != 'X']),
      HIT_OUT_SHARKED_ALL_ZONE           = sum(HIT_OUT_SHARKED[ZONE_LOGICAL_AFL != 'X']),
      HIT_OUT_SHARK_ALL_ZONE             = sum(HIT_OUT_SHARK[ZONE_LOGICAL_AFL != 'X']),
      HIT_OUT_TO_ADVANTAGE_ALL_ZONE      = sum(HIT_OUT_TO_ADVANTAGE[ZONE_LOGICAL_AFL != 'X']),
      ST_SCORE_LAUNCH_ALL_ZONE           = sum(ST_SCORE_LAUNCH[ZONE_LOGICAL_AFL != 'X']),
      ST_BEHIND_LAUNCH_ALL_ZONE          = sum(ST_BEHIND_LAUNCH[ZONE_LOGICAL_AFL != 'X']),
      ST_GOAL_LAUNCH_ALL_ZONE            = sum(ST_GOAL_LAUNCH[ZONE_LOGICAL_AFL != 'X']),
      RATING_HITOUTS_ALL_ZONE            = sum(RATING_HITOUTS[ZONE_LOGICAL_AFL != 'X']),
      RANKING_PTS_ALL_ZONE               = sum(RANKING_PTS[ZONE_LOGICAL_AFL != 'X']),
      ###
      CHAIN_METRES                       = ifelse(ZONE_LOGICAL_AFL == 'X', CHAIN_METRES - CHAIN_METRES_ALL_ZONE, CHAIN_METRES),
      CHAIN_METRES_NET                   = ifelse(ZONE_LOGICAL_AFL == 'X', CHAIN_METRES_NET - CHAIN_METRES_NET_ALL_ZONE, CHAIN_METRES_NET),
      CHAIN_METRES_NET_ST                = ifelse(ZONE_LOGICAL_AFL == 'X', CHAIN_METRES_NET_ST - CHAIN_METRES_NET_ST_ALL_ZONE, CHAIN_METRES_NET_ST),
      CHAIN_METRES_REPLY                 = ifelse(ZONE_LOGICAL_AFL == 'X', CHAIN_METRES_REPLY - CHAIN_METRES_REPLY_ALL_ZONE, CHAIN_METRES_REPLY),
      CHAIN_METRES_REPLY_ST              = ifelse(ZONE_LOGICAL_AFL == 'X', CHAIN_METRES_REPLY_ST - CHAIN_METRES_REPLY_ST_ALL_ZONE, CHAIN_METRES_REPLY_ST),
      CHAIN_METRES_ST                    = ifelse(ZONE_LOGICAL_AFL == 'X', CHAIN_METRES_ST - CHAIN_METRES_ST_ALL_ZONE, CHAIN_METRES_ST),
      FIRST_POSSESSION_TO_CLEAR          = ifelse(ZONE_LOGICAL_AFL == 'X', FIRST_POSSESSION_TO_CLEAR - FIRST_POSSESSION_TO_CLEAR_ALL_ZONE, FIRST_POSSESSION_TO_CLEAR),
      FIRST_POSSESSION                   = ifelse(ZONE_LOGICAL_AFL == 'X', FIRST_POSSESSION - FIRST_POSSESSION_ALL_ZONE, FIRST_POSSESSION),
      CLEARANCE                          = ifelse(ZONE_LOGICAL_AFL == 'X', CLEARANCE - CLEARANCE_ALL_ZONE, CLEARANCE),
      STOPPAGE                           = ifelse(ZONE_LOGICAL_AFL == 'X', STOPPAGE - STOPPAGE_ALL_ZONE, STOPPAGE),
      HITOUT                             = ifelse(ZONE_LOGICAL_AFL == 'X', HITOUT - HITOUT_ALL_ZONE, HITOUT),
      HIT_OUT_SHARKED                    = ifelse(ZONE_LOGICAL_AFL == 'X', HIT_OUT_SHARKED - HIT_OUT_SHARKED_ALL_ZONE, HIT_OUT_SHARKED),
      HIT_OUT_SHARK                      = ifelse(ZONE_LOGICAL_AFL == 'X', HIT_OUT_SHARK - HIT_OUT_SHARK_ALL_ZONE, HIT_OUT_SHARK),
      HIT_OUT_TO_ADVANTAGE               = ifelse(ZONE_LOGICAL_AFL == 'X', HIT_OUT_TO_ADVANTAGE - HIT_OUT_TO_ADVANTAGE_ALL_ZONE, HIT_OUT_TO_ADVANTAGE),
      ST_SCORE_LAUNCH                    = ifelse(ZONE_LOGICAL_AFL == 'X', ST_SCORE_LAUNCH - ST_SCORE_LAUNCH_ALL_ZONE, ST_SCORE_LAUNCH),
      ST_BEHIND_LAUNCH                   = ifelse(ZONE_LOGICAL_AFL == 'X', ST_BEHIND_LAUNCH - ST_BEHIND_LAUNCH_ALL_ZONE, ST_BEHIND_LAUNCH),
      ST_GOAL_LAUNCH                     = ifelse(ZONE_LOGICAL_AFL == 'X', ST_GOAL_LAUNCH - ST_GOAL_LAUNCH_ALL_ZONE, ST_GOAL_LAUNCH),
      RATING_HITOUTS                     = ifelse(ZONE_LOGICAL_AFL == 'X', RATING_HITOUTS - RATING_HITOUTS_ALL_ZONE, RATING_HITOUTS),
      RANKING_PTS                        = ifelse(ZONE_LOGICAL_AFL == 'X', RANKING_PTS - RANKING_PTS_ALL_ZONE, RANKING_PTS)
      ###
    )  %>%
    group_by(PERIOD, SQUAD_ID, ZONE_LOGICAL_AFL) %>%
    mutate( INTERCEPT_OTHER              = INTERCEPT_OTHER + INTERCEPT_OTHER_KO) %>%
    dplyr::select(-INTERCEPT_OTHER_KO) # this should not be required - double check (will be removed in line 222)
  
  # Feature engineering
  returnData$MATCH_ID       <- matchDetails$id[1]
  returnData$SEASON_ID      <- matchDetails$seasonId[1]
  returnData$GROUP_ROUND_NO <- matchDetails$roundNumber[1]
  returnData$VENUE_NAME     <- matchDetails$venue.name[1]
  returnData$SQUAD_NAME     <- NA
  returnData$SQUAD_NAME[which(returnData$SQUAD_ID == matchDetails$home.id[1])] <- matchDetails$home.name[1]
  returnData$SQUAD_NAME[which(returnData$SQUAD_ID != matchDetails$home.id[1])] <- matchDetails$away.name[1]
  returnData$OPP_SQUAD_NAME <- NA
  returnData$OPP_SQUAD_NAME[which(returnData$SQUAD_ID == matchDetails$home.id[1])] <- matchDetails$away.name[1]
  returnData$OPP_SQUAD_NAME[which(returnData$SQUAD_ID != matchDetails$home.id[1])] <- matchDetails$home.name[1]
  returnData$SQUAD_MARGIN   <- NA
  returnData$SQUAD_MARGIN[which(returnData$SQUAD_ID == matchDetails$home.id[1])] <- matchDetails$home.score.points[1]-matchDetails$away.score.points[1]
  returnData$SQUAD_MARGIN[which(returnData$SQUAD_ID != matchDetails$home.id[1])] <- matchDetails$away.score.points[1]-matchDetails$home.score.points[1]
  
  # Add home & away margins to get quarter-level margin for each squad [dplyr intentionally over baseR here]
  returnData <- returnData %>%
    left_join(., matchPeriodScores[c(1,2,4)], by = c("SQUAD_ID"="home.id","PERIOD"="period")) %>%
    left_join(., matchPeriodScores[c(1,3,5)], by = c("SQUAD_ID"="away.id","PERIOD"="period")) %>%
    mutate(MARGIN = coalesce(home.margin, away.margin)) %>%
    relocate(MARGIN, .after = "PERIOD")
  
  # Apply column filtering/ordering (will naturally remove '_ALL_ZONE' cols from above)
  returnData        <- returnData[, getSquadSummaryFileExposedFields]
  
  # Convert 'zone' to an ordered factor
  returnData$ZONE_LOGICAL_AFL <- factor(returnData$ZONE_LOGICAL_AFL , levels = c("D50", "DM", "AM", "F50", "X"))
  
  # Order by 'squad.name', 'period' then 'zone'
  returnData$SQUAD_NAME <- factor(returnData$SQUAD_NAME, levels = c(matchDetails$home.name[1], matchDetails$away.name[1]))
  returnData            <- returnData[order(returnData$SQUAD_NAME, returnData$PERIOD, returnData$ZONE_LOGICAL_AFL ), ]
  
  # Convert factors to char (this occurs after manipulation above with zone logical and squad name)
  returnData$SQUAD_NAME       <- as.character(returnData$SQUAD_NAME)
  returnData$ZONE_LOGICAL_AFL <- as.character(returnData$ZONE_LOGICAL_AFL)
  
  # Output
  return(returnData)
  
}

#'AFL Player Summary File
#'
#'Get the AFL Player Summary File formerly available via the support site.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame in the same format and structure as the AFL Club Transaction Feed file formerly available via the support site.
#' \itemize{
#'    \item \code{MATCH_ID} A unique numerical identifier of a match.
#'    \item \code{SEASON_ID} A numerical identifier of a season.
#'    \item \code{GROUP_ROUND_NO} The round number of the match. Continues to count up during finals.
#'    \item \code{VENUE_NAME} The name of the match venue.
#'    \item \code{PERSON_ID} A unique numerical identifier for the player assigned to the given row.
#'    \item \code{FULLNAME} The fullname of the player assigned to the given row.
#'    \item \code{SQUAD_NAME} The name of the squad for the given row.
#'    \item \code{OPP_SQUAD_NAME} The name of the opposition squad for the given row.
#'    \item \code{SQUAD_MARGIN} The final margin of the match in relation to the team listed under SQUAD_NAME.
#'    \item \code{MARGIN} The margin at the end of the given period in relation to the team listed under SQUAD_NAME.
#'    \item \code{ZONE_LOGICAL_AFL} The zone in which the values within metrics that follow are belonging to, relative to the squad listed under SQUAD_NAME.
#'}
#'@examples
#'getPlayerSummaryFile(matchId = 120390401)
#'@export
getPlayerSummaryFile <- function(matchId,...) {
  
  # Hitting API for metadata
  rawResponse       <- cdAPIresponse(endpoint = paste('matches',matchId,sep='/'),...)
  if(is.null(rawResponse)) return(NULL); listResponse <- rawResponse %>% resp_body_json(simplifyVector = TRUE)
  matchDetails      <- as.data.frame(cbind(listResponse,listResponse$periods))[,matchDetailsCols]
  matchPeriodScores <- getPeriodScores(matchId)[,c("period","home.id","away.id","home.margin","away.margin")]
  
  # AFL Mens Check
  if(!isAFL(matchDetails$leagueId[1])) {
    message("Error:\n--> The matchId passed to getPlayerSummaryFile() is not an AFL Mens match.")
    return(NULL)
  }
  
  # List of periods to iterate over
  maxPeriod        <- if(max(matchDetails$period)>4) max(matchDetails$period) else max(matchDetails$period); 
  matchPeriodsList <- as.list(1:maxPeriod) 
  
  # Not sure this is efficient but see how the below are being used
  Squads  <- data.frame("SQUAD_ID" = c(matchDetails$home.id[1], matchDetails$away.id[1]))
  periods <- data.frame("PERIOD"   = c(1:maxPeriod))
  zones   <- data.frame("ZONE_LOGICAL_AFL"= c('D50','DM','AM','F50','X')) 
  players <- getMatchPersons(matchId) %>%
    dplyr::select(PERSON_ID = 'person.id',FULLNAME = 'person.name', SQUAD_ID= 'squad.id', person.surname) %>%
    mutate(PERSON_ID = as.numeric(PERSON_ID))
  
  # Remove and instantiate inside package - rename as player/squad versions
  zonedMetricStrings         <- paste("list(", paste0('"',zonedMetrics_PlatformNames_Player,'"', collapse = ','),")")
  zonelessMetricStrings      <- paste("list(", paste0('"',zonelessMetrics_PlatformNames_Player,'"',  collapse = ','),")")
  
  # Use lapply to build a payload for each quarter as defined by matchPeriodList
  playerSummaryFilePayload <- lapply(matchPeriodsList, function(period) {
    payload <- list(
      playerMetricRequests = list(
        list(
          metricCodes = eval(parse(text=zonedMetricStrings)),
          team = NA,
          periods = list(period),
          zones = list("D50") , 
          id = "D50"
        ),
        list(
          metricCodes = eval(parse(text=zonedMetricStrings)),
          team = NA,
          periods = list(period),
          zones = list("DM") , 
          id = "DM"
        ),
        list(
          metricCodes = eval(parse(text=zonedMetricStrings)),
          team = NA,
          periods = list(period),
          zones = list("AM"),
          id = "AM"
        ),
        list(
          metricCodes = eval(parse(text=zonedMetricStrings)),
          team = NA,
          periods = list(period),
          zones = list("F50"),
          id = "F50"
        ),
        list(
          metricCodes = eval(parse(text=zonelessMetricStrings)),   ####metrics in X zone with no zone filter on this part of the call
          team = NA,
          periods = list(period),    # zoneless and ones that exist in both
          zones = NA,
          id="X"
        )
      )
    )
  })
  
  # Use post endpoint function to hit 
  apiPlayerSummaryFile <- do.call(rbind, lapply(unlist(matchPeriodsList), function(x) {
    as.data.frame(getPlayerStatsPOST(matchId = matchId, payload = playerSummaryFilePayload[[x]], info = TRUE))
  }))[,c("match.id","squad.name","squad.code","squad.id","player.name","player.display","player.id","stat.code","stat.name","value","info.periods","id")]
  
  # Make info.periods numeric
  apiPlayerSummaryFile$info.periods <- as.numeric(apiPlayerSummaryFile$info.periods)
  
  ####create a empty dataframe that is: all SF metrics wide, by zones, by periods
  empty <- tidyr::expand_grid(playerSummaryFile_lookup, periods, zones, players)
  
  # Turn from long to wide
  # Logic in here gets all the metrics that exist in both the X zone and in other zones and grabs:
  ### the response without a zone filter and then subtracts each of the zone responses of the same metric to get the metrics assigned to the 'M' zone
  
  ###join api response to empty data frame, joining by metric, zone, period and squad
  returnData <- empty %>%
    left_join(apiPlayerSummaryFile,
              by = c("PLATFORM_METRIC_CODE" = "stat.code",
                     "ZONE_LOGICAL_AFL"     = "id",
                     "PERIOD"               = "info.periods",
                     "PERSON_ID"            = "player.id",
                     "SQUAD_ID"             = "squad.id"
              )) 
  
  # Make NA's 0 here before pivoting
  returnData$value[is.na(returnData$value)] <- 0
  returnData$value<- ifelse(returnData$PLATFORM_METRIC_CODE %in% playerSummaryFile_roundedMetrics1DP,round(returnData$value,1),returnData$value)
  returnData$value<- ifelse(returnData$PLATFORM_METRIC_CODE %in% playerSummaryFile_roundedMetrics0DP,round(returnData$value,0),returnData$value)
  
  # Pivot to wide & calculate additional metrics
  returnData <- returnData %>% 
    dplyr::select(-PLATFORM_METRIC_CODE, - match.id, - squad.name, - squad.code, -player.name, -player.display, -stat.name) %>%
    pivot_wider(names_from = SF_METRIC_CODE, values_from = value) %>%
    group_by(PERIOD, SQUAD_ID, PERSON_ID) %>%
    mutate(
      FIRST_POSSESSION_ALL_ZONE          = sum(FIRST_POSSESSION[ZONE_LOGICAL_AFL != 'X']),
      CLEARANCE_ALL_ZONE                 = sum(CLEARANCE[ZONE_LOGICAL_AFL!= 'X']),
      HITOUT_ALL_ZONE                    = sum(HITOUT[ZONE_LOGICAL_AFL != 'X']),
      HIT_OUT_SHARKED_ALL_ZONE           = sum(HIT_OUT_SHARKED[ZONE_LOGICAL_AFL != 'X']),
      HIT_OUT_SHARK_ALL_ZONE             = sum(HIT_OUT_SHARK[ZONE_LOGICAL_AFL != 'X']),
      HIT_OUT_TO_ADVANTAGE_ALL_ZONE      = sum(HIT_OUT_TO_ADVANTAGE[ZONE_LOGICAL_AFL != 'X']),
      RATING_HITOUTS_ALL_ZONE            = sum(RATING_HITOUTS[ZONE_LOGICAL_AFL != 'X']),
      RANKING_PTS_ALL_ZONE               = sum(RANKING_PTS[ZONE_LOGICAL_AFL != 'X']),
      ###
      FIRST_POSSESSION                   = ifelse(ZONE_LOGICAL_AFL == 'X', FIRST_POSSESSION  - FIRST_POSSESSION_ALL_ZONE, FIRST_POSSESSION ),
      CLEARANCE                          = ifelse(ZONE_LOGICAL_AFL == 'X', CLEARANCE - CLEARANCE_ALL_ZONE, CLEARANCE),
      HITOUT                             = ifelse(ZONE_LOGICAL_AFL == 'X', HITOUT - HITOUT_ALL_ZONE, HITOUT),
      HIT_OUT_SHARKED                    = ifelse(ZONE_LOGICAL_AFL == 'X', HIT_OUT_SHARKED - HIT_OUT_SHARKED_ALL_ZONE, HIT_OUT_SHARKED),
      HIT_OUT_SHARK                      = ifelse(ZONE_LOGICAL_AFL == 'X', HIT_OUT_SHARK - HIT_OUT_SHARK_ALL_ZONE, HIT_OUT_SHARK),
      HIT_OUT_TO_ADVANTAGE               = ifelse(ZONE_LOGICAL_AFL == 'X', HIT_OUT_TO_ADVANTAGE - HIT_OUT_TO_ADVANTAGE_ALL_ZONE, HIT_OUT_TO_ADVANTAGE),
      RATING_HITOUTS                     = ifelse(ZONE_LOGICAL_AFL == 'X', RATING_HITOUTS - RATING_HITOUTS_ALL_ZONE , RATING_HITOUTS),
      RANKING_PTS                        = ifelse(ZONE_LOGICAL_AFL == 'X', RANKING_PTS - RANKING_PTS_ALL_ZONE , RANKING_PTS)
      
    ) %>%
    group_by(PERIOD, SQUAD_ID, ZONE_LOGICAL_AFL) %>%
    mutate(
      INTERCEPT_OTHER                    = INTERCEPT_OTHER + INTERCEPT_OTHER_KO
    )
  
  # Feature engineering
  returnData$MATCH_ID       <- matchDetails$id[1]
  returnData$SEASON_ID      <- matchDetails$seasonId[1]
  returnData$GROUP_ROUND_NO <- matchDetails$roundNumber[1]
  returnData$VENUE_NAME     <- matchDetails$venue.name[1]
  returnData$SQUAD_NAME     <- NA
  returnData$SQUAD_NAME[which(returnData$SQUAD_ID == matchDetails$home.id[1])] <- matchDetails$home.name[1]
  returnData$SQUAD_NAME[which(returnData$SQUAD_ID != matchDetails$home.id[1])] <- matchDetails$away.name[1]
  returnData$OPP_SQUAD_NAME <- NA
  returnData$OPP_SQUAD_NAME[which(returnData$SQUAD_ID == matchDetails$home.id[1])] <- matchDetails$away.name[1]
  returnData$OPP_SQUAD_NAME[which(returnData$SQUAD_ID != matchDetails$home.id[1])] <- matchDetails$home.name[1]
  returnData$SQUAD_MARGIN   <- NA
  returnData$SQUAD_MARGIN[which(returnData$SQUAD_ID == matchDetails$home.id[1])] <- matchDetails$home.score.points[1]-matchDetails$away.score.points[1]
  returnData$SQUAD_MARGIN[which(returnData$SQUAD_ID != matchDetails$home.id[1])] <- matchDetails$away.score.points[1]-matchDetails$home.score.points[1]
  returnData$ZONE_LOGICAL_AFL <- factor(returnData$ZONE_LOGICAL_AFL, levels = c("D50", "DM", "AM", "F50", "X"))
  
  # Add home & away margins to get quarter-level margin for each squad [dplyr intentionally over baseR here]
  returnData <- returnData %>%
    left_join(., matchPeriodScores[c("period","home.id","home.margin")], by = c("SQUAD_ID"="home.id","PERIOD"="period")) %>%
    left_join(., matchPeriodScores[c("period","away.id","away.margin")], by = c("SQUAD_ID"="away.id","PERIOD"="period")) %>%
    left_join(., matchDetails[c("period","periodSecs")], by = c("PERIOD"="period")) %>%
    mutate(MARGIN          = coalesce(home.margin, away.margin),
           TOG_PERIOD_SECS = ifelse(ZONE_LOGICAL_AFL == 'X',periodSecs,0)) %>%
    relocate(MARGIN, .after = "PERIOD") %>%
    arrange(SQUAD_NAME, person.surname, FULLNAME, PERIOD, ZONE_LOGICAL_AFL)
  
  # Apply column filtering/ordering (will naturally remove '_ALL_ZONE' cols from above)
  returnData        <- returnData[, getPlayerSummaryFileExposedFields]
  
  # Convert factors to char (this occurs after manipulation above with zone logical and squad name)
  returnData$SQUAD_NAME       <- as.character(returnData$SQUAD_NAME)
  returnData$ZONE_LOGICAL_AFL <- as.character(returnData$ZONE_LOGICAL_AFL)
  
  # Output
  return(returnData)
}

#'Match Stoppages
#'
#'Get a dataframe of stoppages for a match.
#'@param matchId A unique numerical identifier of a match.
#'@param stoppageAttendees A logical value indicating whether to include the attendees of the stoppage. Default is \code{FALSE}.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with all of the stoppages for a given match. 
#' \itemize{
#'   \item \code{match.id} A unique numerical identifier for a match.
#'   \item \code{type.name} The name of the stoppage type (ie. 'Centre Bounce').
#'   \item \code{type.code} A short code representing the stoppage type.
#'   \item \code{trx.id} A unique numerical identifier for a transaction.
#'   \item \code{period} The period in which the transaction occurred.
#'   \item \code{period.seconds} The elapsed time (in seconds) within the period of the transaction.
#'   \item \code{stoppage.location.x} The x-coordinate of the stoppage on the field.
#'   \item \code{stoppage.location.y} The y-coordinate of the stoppage on the field.
#'   \item \code{stoppage.location.standard.x} The x-coordinate of the stoppage transformed to standard dimensions.
#'   \item \code{stoppage.location.standard.y} The y-coordinate of the stoppage transformed to standard dimensions.
#'   \item \code{hitout.id} The transaction id for the hit-out at the stoppage.
#'   \item \code{hitout.name} The name of the hit-out type.
#'   \item \code{hitout.code} A short code representing the hit-out type.
#'   \item \code{hitout.period.seconds} The elapsed time (in seconds) within the period of the hit-out.
#'   \item \code{hitout.player.displayname} The display name of the player credited with the hit-out.
#'   \item \code{hitout.player.fullname} The full name of the player credited with the hit-out.
#'   \item \code{hitout.player.id} A unique numerical identifier for the player credited with the hit-out.
#'   \item \code{hitout.player.squad.id} A unique numerical identifier for the squad of the player credited with the hit-out.
#'   \item \code{first.possession.id} The transaction id for the first possession after the stoppage.
#'   \item \code{first.possession.name} The name of the first possession type.
#'   \item \code{first.possession.code} A short code representing the first possession type.
#'   \item \code{first.possession.period.seconds} The elapsed time (in seconds) within the period of the first possession.
#'   \item \code{first.possession.zone} The zone where the first possession occurred.
#'   \item \code{first.possession.player.displayname} The display name of the player gaining the first possession.
#'   \item \code{first.possession.player.fullname} The full name of the player gaining the first possession.
#'   \item \code{first.possession.player.id} A unique numerical identifier for the player gaining the first possession.
#'   \item \code{first.possession.player.squad.id} A unique numerical identifier for the squad of the player gaining the first possession.
#'   \item \code{clearance.id} A unique numerical identifier for the clearance.
#'   \item \code{clearance.name} The name of the clearance type.
#'   \item \code{clearance.code} A short code representing the clearance type.
#'   \item \code{clearance.period.seconds} The elapsed time (in seconds) within the period of the clearance.
#'   \item \code{clearance.zone} The zone where the clearance occurred.
#'   \item \code{clearance.player.displayname} The display name of the player performing the clearance.
#'   \item \code{clearance.player.fullname} The full name of the player performing the clearance.
#'   \item \code{clearance.player.id} A unique numerical identifier for the player performing the clearance.
#'   \item \code{clearance.player.squad.id} A unique numerical identifier for the squad of the player performing the clearance.
#'   \item \code{exit.id} A unique numerical identifier for the stoppage exit.
#'   \item \code{exit.name} The name of the stoppage exit type.
#'   \item \code{exit.code} A short code representing the stoppage exit type.
#'   \item \code{exit.period.seconds} The elapsed time (in seconds) within the period of the stoppage exit.
#'   \item \code{exit.zone} The zone where the stoppage exit occurred.
#'   \item \code{exit.type} The type of stoppage exit (e.g., kick, handball).
#'   \item \code{exit.pressure} The level of defensive pressure applied during the stoppage exit.
#'   \item \code{exit.player.displayname} The display name of the player performing the stoppage exit.
#'   \item \code{exit.player.fullname} The full name of the player performing the stoppage exit.
#'   \item \code{exit.player.id} A unique numerical identifier for the player performing the stoppage exit.
#'   \item \code{exit.player.squad.id} A unique numerical identifier for the squad of the player performing the stoppage exit.
#'   \item \code{exit.kicking.foot} The foot used by the player for the stoppage exit kick.
#'   \item \code{exit.kicking.intent} The intent of the player for the stoppage exit kick.
#'   \item \code{exit.kicking.distance} The distance of the stoppage exit kick.
#'   \item \code{exit.kicking.direction} The direction of the stoppage exit kick.
#'   \item \code{exit.location.x} The x-coordinate of the stoppage exit on the field.
#'   \item \code{exit.location.y} The y-coordinate of the stoppage exit on the field.
#'   \item \code{exit.location.x.std} The x-coordinate of the stoppage exit transformed to standard dimensions.
#'   \item \code{exit.location.y.std} The y-coordinate of the stoppage exit transformed to standard dimensions.
#'   \item \code{stoppage.attendance.name} The name of the stoppage being attended (ie. 'Ball Up Ruck Contest')
#'   \item \code{stoppage.attendance.code} A short code representing the type of stoppage being attended.
#'   \item \code{stoppage.attendance.id} The transaction id that the stoppage attendance is associated to.
#'   \item \code{stoppage.attendance.period.seconds} The elapsed time (in seconds) within the period of the particular stoppage attendance.
#'   \item \code{score.squad.id} The squad.id of the squad responsible for the score.
#'   \item \code{score.type} The type of score from the clearance.
#'   \item \code{score.points} The points awarded for the score.

#'   - The below fields will only be present when \code{stoppageAttendees = TRUE}\cr

#'   \item \code{stoppage.attendance.home.fullname1} when \code{stoppageAttendees = TRUE}: The full name of the first player attending the stoppage for the home squad.
#'   \item \code{stoppage.attendance.home.displayname1} when \code{stoppageAttendees = TRUE}: The display name of the first player attending the stoppage for the home squad.
#'   \item \code{stoppage.attendance.home.personId1} when \code{stoppageAttendees = TRUE}: A unique numerical identifier for the first player attending the stoppage for the home squad.
#'   \item \code{stoppage.attendance.home.fullname2} when \code{stoppageAttendees = TRUE}: The full name of the second player attending the stoppage for the home squad.
#'   \item \code{stoppage.attendance.home.displayname2} when \code{stoppageAttendees = TRUE}: The display name of the second player attending the stoppage for the home squad.
#'   \item \code{stoppage.attendance.home.personId2} when \code{stoppageAttendees = TRUE}: A unique numerical identifier for the second player attending the stoppage for the home squad.
#'   \item \code{stoppage.attendance.home.fullname3} when \code{stoppageAttendees = TRUE}: The full name of the third player attending the stoppage for the home squad.
#'   \item \code{stoppage.attendance.home.displayname3} when \code{stoppageAttendees = TRUE}: The display name of the third player attending the stoppage for the home squad.
#'   \item \code{stoppage.attendance.home.personId3} when \code{stoppageAttendees = TRUE}: A unique numerical identifier for the third player attending the stoppage for the home squad.
#'   \item \code{stoppage.attendance.home.fullname4} when \code{stoppageAttendees = TRUE}: The full name of the fourth player attending the stoppage for the home squad.
#'   \item \code{stoppage.attendance.home.displayname4} when \code{stoppageAttendees = TRUE}: The display name of the fourth player attending the stoppage for the home squad.
#'   \item \code{stoppage.attendance.home.personId4} when \code{stoppageAttendees = TRUE}: A unique numerical identifier for the fourth player attending the stoppage for the home squad.
#'   \item \code{stoppage.attendance.away.fullname1} when \code{stoppageAttendees = TRUE}: The full name of the first player attending the stoppage for the away squad.
#'   \item \code{stoppage.attendance.away.displayname1} when \code{stoppageAttendees = TRUE}: The display name of the first player attending the stoppage for the away squad.
#'   \item \code{stoppage.attendance.away.personId1} when \code{stoppageAttendees = TRUE}: A unique numerical identifier for the first player attending the stoppage for the away squad.
#'   \item \code{stoppage.attendance.away.fullname2} when \code{stoppageAttendees = TRUE}: The full name of the second player attending the stoppage for the away squad.
#'   \item \code{stoppage.attendance.away.displayname2} when \code{stoppageAttendees = TRUE}: The display name of the second player attending the stoppage for the away squad.
#'   \item \code{stoppage.attendance.away.personId2} when \code{stoppageAttendees = TRUE}: A unique numerical identifier for the second player attending the stoppage for the away squad.
#'   \item \code{stoppage.attendance.away.fullname3} when \code{stoppageAttendees = TRUE}: The full name of the third player attending the stoppage for the away squad.
#'   \item \code{stoppage.attendance.away.displayname3} when \code{stoppageAttendees = TRUE}: The display name of the third player attending the stoppage for the away squad.
#'   \item \code{stoppage.attendance.away.personId3} when \code{stoppageAttendees = TRUE}: A unique numerical identifier for the third player attending the stoppage for the away squad.
#'   \item \code{stoppage.attendance.away.fullname4} when \code{stoppageAttendees = TRUE}: The full name of the fourth player attending the stoppage for the away squad.
#'   \item \code{stoppage.attendance.away.displayname4} when \code{stoppageAttendees = TRUE}: The display name of the fourth player attending the stoppage for the away squad.
#'   \item \code{stoppage.attendance.away.personId4} when \code{stoppageAttendees = TRUE}: A unique numerical identifier for the fourth player attending the stoppage for the away squad.
#' }
#'@examples
#'getStoppages(matchId = 120390401)
#'getStoppages(matchId = 120390401, stoppageAttendees = TRUE)
#'@export
getStoppages <- function(matchId, stoppageAttendees=FALSE,...){
  
  # Hit endpoint for response
  rawResponse <- cdAPIresponse(matchId, paste('matches',matchId,'stoppages',sep='/'), ...) 
  
  if(is.null(rawResponse)){
    return(rawResponse)
  } else {
    
    # Convert response to flat list
    listResponse <- rawResponse %>% resp_body_json(simplifyVector = TRUE)
    
    # Handle if successful response but no events happened yet (second element of list empty)
    if(is_empty(listResponse[[1]])) {
      returnData        <- data.frame(matrix(ncol = length(getStoppagesExposedFields), nrow = 0))
      names(returnData) <- names(getStoppagesExposedFields)
      message(paste0("\nWarning:\n--> 0 rows of data in response.")) 
      return(returnData)
    } else {
      
      # Convert list into DF
      returnData <- listResponse %>% as.data.frame() %>% jsonlite::flatten()
      
      # Get length of stoppages.attendance.players list - if empty skip the below as there are no attendees to return regardless of if stoppageAttendees = T
      attendLength <- length(unlist(returnData$stoppages.attendance.players[1]))
      
      # This means that if there are no attendees in response, the response wont return any attendee cols in spite of stoppageAttendees = T
      if(stoppageAttendees == T & attendLength > 0){
        
        # Extract stoppages.attendance.players list & stoppage trx id's & unnest
        stoppagePlayers <- returnData[,c("stoppages.id", "stoppages.attendance.players")] %>% tidyr::unnest(stoppages.attendance.players) 
        
        # Get vector of unique squadIds (first squadId listed should be home squad)
        squadIds        <- unique(stoppagePlayers$squadId)
        
        # HOME #
        home      <- stoppagePlayers[stoppagePlayers$squadId == squadIds[1],] %>% rename_with(tolower, .cols = "displayName")
        home$rowN <- with(home, ave(seq_along(stoppages.id), stoppages.id, FUN = seq_along))
        home      <- home %>% pivot_wider(names_from  = rowN, values_from = c(displayname, fullname, personId), names_glue  = "stoppage.attendance.home.{.value}{rowN}") 
        home      <- home[, getStoppages_homeNames[getStoppages_homeNames%in%names(home)], drop = FALSE]
        
        # AWAY #
        away      <- stoppagePlayers[stoppagePlayers$squadId == squadIds[2],] %>% rename_with(tolower, .cols = "displayName")
        away$rowN <- with(away, ave(seq_along(stoppages.id), stoppages.id, FUN = seq_along))
        away      <- away %>% pivot_wider(names_from  = rowN, values_from = c(displayname, fullname, personId), names_glue  = "stoppage.attendance.away.{.value}{rowN}")
        away      <- away[, getStoppages_awayNames[getStoppages_awayNames%in%names(away)], drop = FALSE]
        
        # Match 'stoppages.id' in 'returnData' with 'home'
        match_idx_home <- match(returnData$stoppages.id, home$stoppages.id)
        match_idx_away <- match(returnData$stoppages.id, away$stoppages.id)
        
        # Add columns from 'home' & 'away' to returnData via vector lookup of stoppages.id as opposed to join 
        returnData <- cbind(returnData, home[match_idx_home, -which("stoppages.id" %in% names(home))])  
        returnData <- cbind(returnData, away[match_idx_away, -which("stoppages.id" %in% names(away))])  
        
        # Add stoppageAttendees column names getStoppagesExposedFields to run through below code ([-1] removes 'stoppages.id' triplication)
        # Note: Changes here are locally scoped to within the function
        getStoppagesExposedFields <- c(getStoppagesExposedFields, setNames(getStoppages_homeNames[-1], getStoppages_homeNames[-1]), setNames(getStoppages_awayNames[-1], getStoppages_awayNames[-1]))
        
      } # close stoppageAttendees
      
      # Remove stoppages.attendance.players column regardless of 'stoppageAttendees' TRUE or FALSE
      returnData <- returnData[,-which("stoppages.attendance.players"==names(returnData))]
      
    } # close response has rows
    
    # Get vector of the missing fields (IF ANY) in the call info
    missing <- setdiff(getStoppagesExposedFields ,names(returnData))
    
    # Add on any of the missing columns in the response 
    returnData[missing] <- lapply(missing, function(x) rep(NA, nrow(returnData)))
    
    # Select exposed fields (getStoppagesExposedFields) & rename columns
    returnData        <- returnData[, getStoppagesExposedFields]
    names(returnData) <- names(getStoppagesExposedFields)
    
    return(returnData)
  } # close rawResponse is not NULL
} 

#'Statistic Flow
#'
#'Get time coded transactions for given metric(s) occurring in a match
#'@param matchId A unique numerical identifier of a match.
#'@param metric A text string of specific metric code(s) to be returned. This will result in the endpoint only returning these specific metrics. Note this endpoint is case sensitive and only works with metric codes (ie. \code{c("TACKLE", "GOAL")}
#'@param period A numerical indicator of a period to filter results within a match. Accepts integer values.
#'@param zone A text indicator of a zone on the field to filter results within a match. Accepts string values: \code{"D50","DM","AM","F50","CB"}.
#'@param team A (case-sensitive) text string of the team to return metrics for. Either \code{"home"} or \code{"away"}. Not passing anything to this param will return both teams.
#'@param limit The number of transactions per page to return. The limit and default value is 5000 transactions per page.
#'@param orderBy Order transactions by ascending or descending based on transaction id. Default value is \code{"asc"}.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of metrics for a match for each player.
#'\itemize{
#'    \item \code{trx.id}  A unique numerical identifier for a given transaction, used for ordering chronologically.
#'    \item \code{period} The period of the transaction.
#'    \item \code{period.secs} The elapsed time within the period of a transaction. 
#'    \item \code{zone.logical} The zone in which the transaction takes place, relative to the squad in possession.
#'    \item \code{fullname} The full name of the player.
#'    \item \code{person.id} A unique numerical identifier of the player.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{metric.code} The metric code (ALL_CAPS format).
#'    \item \code{value} The numeric metric value with no formatting applied.
#'}
#'@examples
#'getStatisticFlow(216085122)
#'getStatisticFlow(216085122,metric="TACKLE",period=1,zone='D50')
#'@export
getStatisticFlow <- function(matchId, metric, period = NULL, zone = NULL, team = NULL, limit = NULL, orderBy = NULL, ...){
  
  # Base URL
  baseString   <- paste('matches',matchId,'statistics/flow?',sep='/')                                                 
  
  # Hit API
  rawResponse <- cdAPIresponse(endpoint = paste0(baseString, optionalParams(
    "metric"       = metric , 
    "period"       = period , 
    "zone"         = zone   , 
    "team"         = team   , 
    "limit"        = limit  , 
    "orderBy"      = orderBy 
  )), pagination = TRUE, ...)
  
  if(is.null(rawResponse)){
    return(rawResponse)
  } else {
    # If the raw response is successful, but contains 0 rows
    if(resp_body_json(rawResponse[[1]],simplifyVector = TRUE)$metaData$totalRecords==0){
      returnData        <- data.frame(matrix(ncol = length(getStatisticFlowExposedFields), nrow = 0))
      names(returnData) <- names(getStatisticFlowExposedFields)
      message(paste0("\nWarning:\n--> 0 rows of data in response.")) 
      return(returnData)
    } else {
      
      # Iterate through all pages of rawResponse using the flattenPaginatedTrx() function to unnest
      returnData <- bind_rows(lapply(rawResponse, flattenPaginatedTrx))
      
      # Get vector of the missing fields (IF ANY) in the call info
      missing <- setdiff(getStatisticFlowWhitelist,names(returnData))
      
      # Add on any of the missing columns in the response 
      returnData[missing] <- lapply(missing, function(x) rep(NA, nrow(returnData)))
    }
    
    # Select exposed fields (getStatisticFlowExposedFields) & rename columns
    returnData        <- returnData[, getStatisticFlowExposedFields]
    names(returnData) <- names(getStatisticFlowExposedFields)
  }
  return(returnData)
}

#'Match Ruck Contest Summary
#'
#'Get a summary of ruck contest statistics for a given match.
#'@param matchId A unique numerical identifier of a match.
#'@param stoppageType Filter statistics to a specific type(s) of ruck contest, any one of: \cr
#'\code{'centreBounce', 'ballUp', 'throwIn'}\cr
#'
#'Can accept multiple arguments in a character vector\cr(ie. \code{stoppageType = c('ballUp', 'throwIn')}) 
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a summary of ruck contest statistics for a given match.
#'\itemize{
#'  \item \code{match.id}: The unique identifier for the match.
#'  \item \code{total.contests}: The total number of ruck contests between the home & away ruck combination.
#'  \item \code{home.ruck.squad.code}: Squad code for the home team's ruckman.
#'  \item \code{home.ruck.squad.id}: Squad ID for the home team's ruckman.
#'  \item \code{home.ruck.fullname}: Fullname of the home team's ruckman.
#'  \item \code{home.ruck.display.name}: Display name of the home team's ruckman.
#'  \item \code{home.ruck.person.id}: Person ID of the home team's ruckman.
#'  \item \code{away.ruck.squad.code}: Squad code for the away team's ruckman.
#'  \item \code{away.ruck.squad.id}: Squad ID for the away team's ruckman.
#'  \item \code{away.ruck.fullname}: Fullname of the away team's ruckman.
#'  \item \code{away.ruck.display.name}: Display name of the away team's ruckman.
#'  \item \code{away.ruck.person.id}: Person ID of the away team's ruckman.
#'  \item \code{home.ruck.hitouts}: Total number of hitouts by the home team's ruckman.
#'  \item \code{home.ruck.hitouts.advantage}: Total number of hitouts to advantage by the home team's ruckman.
#'  \item \code{home.ruck.hitouts.sharked}: Total number of hitouts sharked from the home team's ruckman.
#'  \item \code{home.ruck.first.possessions}: Total number of first possessions gathered by the home team while the given home ruck was in the ruck contest.  
#'  \item \code{home.ruck.clearances}: Total number of clearances gathered by the home team while the given home ruck was in the ruck contest.  
#'  \item \code{home.ruck.goals}: Total number of goals gathered by the home team while the given home ruck was in the ruck contest (in home team clearance chains).
#'  \item \code{home.ruck.behinds}: Total number of behinds gathered by the home team while the given home ruck was in the ruck contest (in home team clearance chains).
#'  \item \code{home.ruck.points}: Total number of points gathered by the home team while the given home ruck was in the ruck contest (in home team clearance chains).
#'  \item \code{away.ruck.hitouts}: Total number of hitouts by the away team's ruckman.
#'  \item \code{away.ruck.hitouts.advantage}: Total number of hitouts to advantage by the away team's ruckman.
#'  \item \code{away.ruck.hitouts.sharked}: Total number of hitouts sharked from the away team's ruckman.
#'  \item \code{away.ruck.first.possessions}: Total number of first possessions gathered by the away team while the given away ruck was in the ruck contest.  
#'  \item \code{away.ruck.clearances}: Total number of clearances gathered by the away team while the given away ruck was in the ruck contest.
#'  \item \code{away.ruck.goals}: Total number of goals gathered by the away team while the given away ruck was in the ruck contest (in away team clearance chains).
#'  \item \code{away.ruck.behinds}: Total number of behinds gathered by the away team while the given away ruck was in the ruck contest (in away team clearance chains).
#'  \item \code{away.ruck.points}: Total number of points gathered by the away team while the given away ruck was in the ruck contest (in away team clearance chains).
#'}
#'@examples
#'getRuckContests(120390401)
#'getRuckContests(120390401, stoppageType=c('ballUp', 'throwIn'))
#'@export
getRuckContests <- function(matchId, stoppageType = NULL, ...){
  
  # Base URL
  baseString   <- paste('matches',matchId,'summary/ruckcontests?',sep='/')
  
  # Hit API
  rawResponse <- cdAPIresponse(endpoint = paste0(baseString, optionalParams("stoppageType" = stoppageType)),...)
  
  if(is.null(rawResponse)){
    return(rawResponse)
  } else {
    # Convert response to flat list
    listResponse <- rawResponse %>% resp_body_json(simplifyVector = TRUE)
    
    # Handle if successful response but no events happened yet (second element of list empty)
    if(is_empty(listResponse[[2]])) {
      returnData        <- data.frame(matrix(ncol = length(getRuckContestsExposedFields), nrow = 0))
      names(returnData) <- names(getRuckContestsExposedFields)
      message(paste0("\nWarning:\n--> 0 rows of data in response.")) 
      return(returnData)
    } else {
      # Convert list into DF
      returnData <- listResponse %>% as.data.frame() %>% jsonlite::flatten()
      
      # Get vector of the missing fields (IF ANY) in the call info
      missing <- setdiff(getRuckContestsExposedFields,names(returnData))
      
      # Add on any of the missing columns in the response 
      returnData[missing] <- lapply(missing, function(x) rep(NA, nrow(returnData)))
    }
    
    # Select exposed fields (getRuckContests) & rename columns
    returnData        <- returnData[, getRuckContestsExposedFields]
    names(returnData) <- names(getRuckContestsExposedFields)
    
    return(returnData)
  }
} 