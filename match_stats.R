#'Match Chains
#'
#'Get a list of possession chains for a match.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of possession chains for a match, with one row per chain. NULL if the match is yet to start.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{squad.name} The name of the squad in possession during the chain.
#'    \item \code{squad.code} A short code to represent the squad in possession during the chain.
#'    \item \code{period} The period of the possession chain.
#'    \item \code{start.id} The transaction ID of the start of the chain.
#'    \item \code{start.secs} The elapsed time within the period at the start of the chain.
#'    \item \code{start.name} The starting state of the chain.
#'    \item \code{start.code} A short code representing the starting state of the chain.
#'    \item \code{start.type} The start type of the chain.
#'    \item \code{start.type.code} A short code representing the starting type of the chain.
#'    \item \code{start.zone} The starting zone of the chain, relative to the squad in possession.
#'    \item \code{start.zone.physical} The starting zone of the chain, relative to the physical ground.
#'    \item \code{launch.id} A unique numerical identifier of the player who launched the chain.
#'    \item \code{launch.name} The full name of the player who launched the chain.
#'    \item \code{launch.display} The display name of the player who launched the chain, represented as first initial and surname.
#'    \item \code{end.id} The transaction ID of the end of the chain.
#'    \item \code{end.secs} The elapsed time within the period at the end of the chain.
#'    \item \code{end.name} The final state of the chain.
#'    \item \code{end.code} A short code representing the final state of the chain.
#'    \item \code{end.type} The end type of the chain.
#'    \item \code{end.type.code} A short code representing the end type of the chain.
#'    \item \code{end.zone} The final zone of the chain, relative to the squad in possession.
#'    \item \code{end.zone.physical} The final zone of the chain, relative to the physical ground.
#'    \item \code{end.x} The x-coordinate of the end of chain location.
#'    \item \code{end.y} The y-coordinate of the end of chain location.
#'    \item \code{score.id} The transaction ID of the scoring shot, if a score was generated during the chain.
#'    \item \code{score.result} The result scoring shot, if a score was generated during the chain.
#'    \item \code{score.points} The points generated by the scoring shot, if a score was generated during the chain.
#'    \item \code{score.player.id} A unique numerical identifier of the player who scored within the chain.
#'    \item \code{score.player.name} The full name of the player who scored within the chain.
#'    \item \code{score.player.display} The display name of the player who scored within the chain, represented as first initial and surname.
#'    \item \code{turnover.id} A unique numerical identifier of the player who turned the ball over at the end of the chain.
#'    \item \code{turnover.name} The full name of the player who turned the ball overa at the end of the chain.
#'    \item \code{turnover.display} The display name of the player who turned the ball overa at the end of the chain, represented as first initial and surname.
#'    \item \code{turnover.type} The type of turnover that was commited. Kick, handball or non-disposal.
#'    \item \code{turnover.state} The match state of the turnover that was commited. Clearing stoppage or General Play.
#'    \item \code{turnover.creation} The creation method of the turnover that was commited. Forced/Unforced Giveaway or Opposition Takeaway.
#'    \item \code{clearance.id} The transaction ID of the clearance that was won within the chain.
#'    \item \code{inside50.id} The transaction ID of the first inside 50 that was generated by the squad in possession within the chain.
#'    \item \code{rebound50.id} The transaction ID of the first rebound 50 that was generated by the squad in possession within the chain.
#'    \item \code{next.id} The transaction ID of the start of the next possession chain.
#'    \item \code{prevoius.id} The transaction ID of the start of the previous possession chain.
#'    \item \code{chain.metres.gained} Metres gained by a team within possession chains, combining measures towards attacking goal and away from defensive goal.
#'    \item \code{chain.metres.gained.reply} Chain Metres conceded to the opposition in the next chain after a turnover.
#'    \item \code{chain.metres.gained.net} Net Metres gained in a chain of possession after subtracting opposition Metres gained after a turnover. Equal to Chain Metres minus Chain Metres Reply.
#'}
#'@examples
#'getChains(216085122)
#'@export
getChains <- function(matchId,...){
  
  rawResponse <- cdAPIresponse(matchId,paste('matches',matchId,'chains',sep='/'),...)
  
  if(is.null(rawResponse)){
    return(rawResponse)
  } else {
    # Convert response to flat list
    listResponse <- fromJSON(content(rawResponse,'text'),flatten=TRUE)
    
    # Handle if successful response but no events happened yet (second element of list empty)
    if(is_empty(listResponse[[2]])) {
      returnData        <- data.frame(matrix(ncol = length(getChainsWhitelist), nrow = 0))
      names(returnData) <- getChainsWhitelist
      message(paste0("\nWarning\n--> 0 rows of data in response.")) 
      return(returnData)
    } else {
      # Convert list into DF
      returnData <- data.frame(listResponse)
      
      # Get vector of the missing fields (IF ANY) in the call info
      missing <- setdiff(getChainsWhitelist,names(returnData))
      
      # Add on any of the missing columns in the response 
      returnData[missing] <- lapply(missing, function(x) rep(NA, nrow(returnData)))
    }
    
    # Select exposed fields (getChainsExposedFields) & rename columns
    returnData        <- returnData[, getChainsExposedFields]
    names(returnData) <- names(getChainsExposedFields)
    
    return(returnData)
  }
}

#'Match Rotations
#'
#'Get a list of rotations for a match.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of rotations for the match, with one row per interchange move.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{id} The transaction ID of the interchange move, used for ordering chronologically.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{period} The period of the interchange move.
#'    \item \code{secs} The elapsed time within the period of the interchange move.
#'    \item \code{off.id} A unique numerical identifier of the player coming off the ground.
#'    \item \code{off.name} The full name of the player coming off the ground.
#'    \item \code{off.display} The display name of the player coming off the ground, represented as first initial and surname.
#'    \item \code{off.reason} The reason for the interchange move.
#'    \item \code{off.code} A short text description of the reason for the interchange move.
#'    \item \code{on.id} A unique numerical identifier of the player coming on the ground. Empty for start-of-match initialisation of the interchange bench.
#'    \item \code{on.name} The full name of the player coming on the ground. Empty for start-of-match initialisation of the interchange bench.
#'    \item \code{on.display} The display name of the player coming on the ground, represented as first initial and surname. Empty for start-of-match initialisation of the interchange bench.
#'}
#'@examples
#'getRotations(216085122)
#'@export
getRotations <- function(matchId,...){
  temp <- cdAPI(paste('matches',matchId,'rotations',sep='/'),df=FALSE,...) 
  r <- temp %>% content()
  rotations <- r$rotations
  if(length(rotations)==0) return(NULL)
  trot <- do.call(bind_rows,lapply(rotations,unlist))
  if(!'on.personId'%in%names(trot)) trot <- trot %>% mutate(on.personId=NA,on.fullname=NA,on.displayName=NA)
  trot %>%
    mutate(match.id=matchId) %>%
    select(match.id,
           id='matchTrxId',
           squad.id,squad.name,squad.code,
           period,secs='periodSecs',
           off.id='off.personId',
           off.name='off.fullname',
           off.display='off.displayName',
           off.reason='off.reason',
           off.code='off.reasonCode',
           on.id='on.personId',
           on.name='on.fullname',
           on.display='on.displayName')
}

#'Match Bench
#'
#'Get the current bench status of all players in a match.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of all players for the match and their current bench status.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{id} A unique numerical identifier of the player.
#'    \item \code{name} The full name of the player.
#'    \item \code{display} The display name of the player, represented as first initial and surname.
#'    \item \code{status} The player's current status.
#'    \item \code{elapsed} Seconds elapsed within the current period since the player's last interchange move.
#'}
#'@examples
#'getBench(216085122)
#'@export
getBench <- function(matchId,...){
  r <- cdAPI(paste('matches',matchId,'rotations',sep='/'),df=FALSE,...) %>%
    content()
  if(length(r$home$players)==0) return(NULL)
  home <- data.frame(with(r$home,data.frame(squadCode,squadId,squadName,stringsAsFactors = FALSE)),data.frame(do.call(bind_rows,lapply(r$home$players,unlist))))
  away <- data.frame(with(r$away,data.frame(squadCode,squadId,squadName,stringsAsFactors = FALSE)),data.frame(do.call(bind_rows,lapply(r$away$players,unlist))))
  temp <- bind_rows(home,away)
  if(!'currentStint.status'%in%names(temp)) temp <- temp %>% mutate(currentStint.status=NA)
  if(!'currentStint.elapsedSecs'%in%names(temp)) temp <- temp %>% mutate(currentStint.status=NA)
  temp %>%
    mutate(match.id=matchId) %>%
    select(match.id,
           squad.id='squadId',
           squad.name='squadName',
           squad.code='squadCode',
           id='personId',
           name='fullname',
           display='displayName',
           status='currentStint.status',
           elapsed='currentStint.elapsedSecs')
}

#'Match Shots
#'
#'Get a list of shots at goal for a match. Also includes rushed behinds.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of shots at goal for a match, with one row per shot.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{id} The transaction ID of the shot, used for ordering chronologically.
#'    \item \code{period} The period of the shot.
#'    \item \code{secs} The elapsed time within the period of the shot.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{player.id} A unique numerical identifier of the player taking the shot.
#'    \item \code{player.name} The full name of the player taking the shot.
#'    \item \code{player.display} The display name of the player taking the shot, represented as first initial and surname.
#'    \item \code{origin} How the player was able to generate a shot at goal.
#'    \item \code{type} The type of shot attempted.
#'    \item \code{angle} A text description of the angle of the shot.
#'    \item \code{distance} A text description of the distance of the shot.
#'    \item \code{x} Distance in metres from the centre of the ground (measuring goal to goal), with the goals being at positive (venue_length / 2).
#'    \item \code{y} Distance in metres from the centre of the ground (measuring boundary to boundary), with the goals being at zero and the boundary line at halfway being at (venue_widht / 2). Positive y is bottom of screen when running to the right.
#'    \item \code{x.std} The x coordinate of the shot transformed to a standard ground dimension (160x141).
#'    \item \code{y.std} The y coordinate of the shot transformed to a standard ground dimension (160x141).
#'    \item \code{accuracy.exp} The expected accuracy of the shot.
#'    \item \code{result} The result of the shot. G / B / R / M.
#'    \item \code{points.exp} The expected points of the shot.
#'    \item \code{points} The number of points obtained from the shot.
#'}
#'@examples
#'getShots(216085122)
#'@export
getShots <- function(matchId,...){
  
  rawResponse <- cdAPIresponse(matchId,paste('matches',matchId,'shots',sep='/'),...)
  
  if(is.null(rawResponse)){
    return(rawResponse)
  } else {
    # Convert response to flat list
    listResponse <- fromJSON(content(rawResponse,'text'),flatten=TRUE)
    
    # Handle if successful response but no events happened yet (second element of list empty)
    if(is_empty(listResponse[[2]])) {
      returnData        <- data.frame(matrix(ncol = length(getShotsWhitelist), nrow = 0))
      names(returnData) <- getShotsWhitelist
      message(paste0("\nWarning\n--> 0 rows of data in response.")) 
      return(returnData)
    } else {
      # Convert list into DF
      returnData <- data.frame(listResponse)
      
      # Get vector of the missing fields (IF ANY) in the call info
      missing <- setdiff(getShotsWhitelist,names(returnData))
      
      # Add on any of the missing columns in the response 
      returnData[missing] <- lapply(missing, function(x) rep(NA, nrow(returnData)))
    }
    
    # Select exposed fields (getShotsExposedFields) & rename columns
    returnData        <- returnData[, getShotsExposedFields]
    names(returnData) <- names(getShotsExposedFields)
    
    return(returnData)
  }
} 

#'Match Squad Stats
#'
#'Get squad stats for a match. Only returns observed metrics.
#'@param matchId A unique numerical identifier of a match.
#'@param period A numerical indicator of a period to filter results within a match. Accepts integer values.
#'@param zone A text indicator of a zone on the field to filter results within a match. Accepts string values "D50","DM","AM","F50".
#'@param context A text indicator of the context for squad statistics. Accepts "For" "Against" or "Diff".
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of metrics for a match for each squad.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{code} The metric code (ALL_CAPS format).
#'    \item \code{name} The metric name (singular).
#'    \item \code{plural} The metric name (plural).
#'    \item \code{value} The numeric metric value with no formatting applied.
#'    \item \code{display} The formatted metric value as a text string.
#'}
#'@examples
#'getSquadStats(216085122)
#'getSquadStats(216085122,period=1,zone='D50')
#'@export
getSquadStats <- function(matchId,period,zone,context,...){
  request_url <- paste('matches',matchId,'statistics/squads',sep='/')
  zcode <- NULL
  pcode <- NULL
  ccode <- NULL
  if(!missing(period)) pcode <- paste(paste('period=',period,sep=''),collapse='&')
  if(!missing(zone)) zcode <- paste(paste('zone=',zone,sep=''),collapse='&')
  if(!missing(context)) ccode <- paste(paste('context=',context,sep=''),collapse='&')
  qcode <- paste(pcode,zcode,ccode,sep='&')
  if(length(qcode)>0){
    if(substr(qcode,nchar(qcode),nchar(qcode))=='&') qcode <- substr(qcode,1,nchar(qcode)-1)
    if(substr(qcode,1,1)=='&') qcode <- substr(qcode,2,nchar(qcode))
    request_url <- paste(request_url,qcode,sep='?')
  }
  temp <- cdAPI(request_url,df=FALSE,...)
  if(is.null(temp)) return(NULL)
  r <- temp %>%
    content()
  home <- with(r$squads[[1]],data.frame(id,name,code,stringsAsFactors=FALSE))
  away <- with(r$squads[[2]],data.frame(id,name,code,stringsAsFactors=FALSE))
  homeStats <- do.call(bind_rows,lapply(r$squads[[1]]$statistics,unlist))
  awayStats <- do.call(bind_rows,lapply(r$squads[[2]]$statistics,unlist))
  if(dim(homeStats)[1]==0 & dim(awayStats)[1]==0) return(NULL)
  data.frame(match.id=matchId,bind_rows(data.frame(home,homeStats),data.frame(away,awayStats))) %>%
    select(match.id,
           squad.id='id',
           squad.name='name',
           squad.code='code',
           code='code.1',
           name='name.1',
           plural='namePlural',
           value,
           display='valueDisplay') %>%
    mutate(value=as.numeric(value))
}

#'Match Player Stats
#'
#'Get player stats for a match. Only returns observed metrics.
#'@param matchId A unique numerical identifier of a match.
#'@param period A numerical indicator of a period to filter results within a match. Accepts integer values.
#'@param zone A text indicator of a zone on the field to filter results within a match. Accepts string values "D50","DM","AM","F50".
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of metrics for a match for each player.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{player.id} A unique numerical identifier of the player.
#'    \item \code{player.name} The full name of the player.
#'    \item \code{player.display} The display name of the player, represented as first initial and surname.
#'    \item \code{code} The metric code (ALL_CAPS format).
#'    \item \code{name} The metric name (singular).
#'    \item \code{plural} The metric name (plural).
#'    \item \code{value} The numeric metric value with no formatting applied.
#'    \item \code{display} The formatted metric value as a text string.
#'}
#'@examples
#'getPlayerStats(216085122)
#'getPlayerStats(216085122,period=1,zone='D50')
#'@export
getPlayerStats <- function(matchId,period,zone,...){
  request_url <- paste('matches',matchId,'statistics/players',sep='/')
  zcode <- NULL
  pcode <- NULL
  if(!missing(period)) pcode <- paste(paste('period=',period,sep=''),collapse='&')
  if(!missing(zone)) zcode <- paste(paste('zone=',zone,sep=''),collapse='&')
  qcode <- paste(pcode,zcode,sep='&')
  if(length(qcode)>0){
    if(substr(qcode,nchar(qcode),nchar(qcode))=='&') qcode <- substr(qcode,1,nchar(qcode)-1)
    if(substr(qcode,1,1)=='&') qcode <- substr(qcode,2,nchar(qcode))
    request_url <- paste(request_url,qcode,sep='?')
  }
  temp <- cdAPI(request_url,df=FALSE,...)
  if(is.null(temp)) return(NULL)
  r <- temp %>%
    content()
  home <- with(r$squads[[1]],data.frame(id,name,code,stringsAsFactors=FALSE))
  away <- with(r$squads[[2]],data.frame(id,name,code,stringsAsFactors=FALSE))
  if(sum(unlist(lapply(r$squads[[1]]$players,function(x) length(x$statistics))))==0 & sum(unlist(lapply(r$squads[[2]]$players,function(x) length(x$statistics))))==0) return(NULL)
  homeStats <- do.call(bind_rows,lapply(r$squads[[1]]$players,function(x){
    details <- with(x,data.frame(personId,fullname,displayName,stringsAsFactors=FALSE))
    stats <- do.call(bind_rows,lapply(x$statistics,function(y) with(y,data.frame(code,name,namePlural,value,valueDisplay,stringsAsFactors = FALSE))))
    data.frame(details,stats,stringsAsFactors=FALSE)
  }))
  awayStats <- do.call(bind_rows,lapply(r$squads[[2]]$players,function(x){
    details <- with(x,data.frame(personId,fullname,displayName,stringsAsFactors=FALSE))
    stats <- do.call(bind_rows,lapply(x$statistics,function(y) with(y,data.frame(code,name,namePlural,value,valueDisplay,stringsAsFactors = FALSE))))
    data.frame(details,stats,stringsAsFactors=FALSE)
  }))
  data.frame(match.id=matchId,bind_rows(data.frame(home,homeStats),data.frame(away,awayStats))) %>%
    select(match.id,
           squad.id='id',
           squad.name='name',
           squad.code='code',
           player.id='personId',
           player.name='fullname',
           player.display='displayName',
           code='code.1',
           name='name.1',
           plural='namePlural',
           value,
           display='valueDisplay') %>%
    mutate(value=as.numeric(value))
}

#'Match Stat Leaders
#'
#'Get leading five players for selected stats for a match.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of the five leading players for selected metrics.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{code} The metric code (ALL_CAPS format).
#'    \item \code{name} The metric name (singular).
#'    \item \code{plural} The metric name (plural).
#'    \item \code{player.id} A unique numerical identifier of the player.
#'    \item \code{player.name} The full name of the player.
#'    \item \code{player.display} The display name of the player, represented as first initial and surname.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{value} The numeric metric value with no formatting applied.
#'    \item \code{display} The formatted metric value as a text string.
#'    \item \code{rank} Dense rank within metric, with ties presented as ties.method='min'.
#'    \item \code{order} Order within the metric with no ties. Ties in metric value are broken by ordering by player surname then firstname.
#'}
#'@examples
#'getLeaders(216085122)
#'@export
getLeaders <- function(matchId,...){
  temp <- cdAPI(paste('matches',matchId,'statistics/leaders',sep='/'),df=FALSE,...)
  if(is.null(temp)) return(NULL)
  r <- temp %>% content()
  stats <- do.call(bind_rows,lapply(r$statistics,function(x){
    details <- with(x,data.frame(code,name,namePlural,stringsAsFactors = FALSE))
    players <- do.call(bind_rows,lapply(x$persons,function(y) {
      if(!'valueDisplay'%in%names(y)) y <- c(y,'valueDisplay'=NA)
      with(y,data.frame(personId,fullname,displayName,squadId,squadName,squadCode,value,valueDisplay,rank,order,stringsAsFactors=FALSE))
    }))
    data.frame(details,players,stringsAsFactors=FALSE)
  }))
  data.frame(match.id='matchId',stats) %>%
    select(match.id,
           code,name,plural='namePlural',
           player.id='personId',
           player.name='fullname',
           player.display='displayName',
           squad.id='squadId',
           squad.name='squadName',
           squad.code='squadCode',
           value,display='valueDisplay',rank,order)
}

#'Period Scores
#'
#'Get a a list of match scores by quarter.
#'@param matchId A unique numerical identifier of a match.
#'@param cumulative Logical. Return scores up to and including that quarter? Defaults to FALSE, which returns scores within the quarter only.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of quarters and scores for each quarter.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{id} The transaction ID of the interchange move, used for ordering chronologically.
#'    \item \code{home.id} A unique numerical identifier of the home squad.
#'    \item \code{home.name} The name of the home squad.
#'    \item \code{home.code} A short code to represent the home squad.
#'    \item \code{away.id} A unique numerical identifier of the away squad.
#'    \item \code{away.name} The name of the away squad.
#'    \item \code{away.code} A short code to represent the away squad.
#'    \item \code{period} The period of the match.
#'    \item \code{home.goals} Goals scored by the home squad.
#'    \item \code{home.behinds} Behinds scored by the home squad.
#'    \item \code{home.points} Points scored by the home squad.
#'    \item \code{home.result} Period result for the home squad. W/L/D.
#'    \item \code{home.margin} Scoreboard margin for the home squad.
#'    \item \code{away.goals} Goals scored by the away squad.
#'    \item \code{away.behinds} Behinds scored by the away squad.
#'    \item \code{away.points} Points scored by the away squad.
#'    \item \code{away.result} Period result for the away squad. W/L/D.
#'    \item \code{away.margin} Scoreboard margin for the away squad.
#'    \item \code{winning.squad.id} The ID of the winning squad.
#'}
#'@examples
#'getPeriodScores(216085122)
#'getPeriodScores(216085122,cumulative=TRUE)
#'@export
getPeriodScores <- function(matchId,cumulative=FALSE,...){
  temp <- cdAPI(paste('matches',matchId,'score',sep='/'),...)
  if(is.null(temp)) return(NULL)
  temp <- temp %>%
    mutate(cumulative=cumulative,
           home.result.cumulative=case_when(home.periods.marginCumulative>0~'W',
                                            home.periods.marginCumulative<0~'L',
                                            TRUE~'D'),
           away.result.cumulative=case_when(home.periods.marginCumulative>0~'L',
                                            home.periods.marginCumulative<0~'W',
                                            TRUE~'D'),
           winning.squad.period=case_when(home.periods.margin>0~home.id,
                                          home.periods.margin<0~away.id,
                                          TRUE~NA_integer_),
           winning.squad.cumulative=case_when(home.periods.marginCumulative>0~home.id,
                                              home.periods.marginCumulative<0~away.id,
                                              TRUE~NA_integer_))
  if(!'home.periods.resultCode'%in%names(temp)) temp <- temp %>% mutate(home.periods.resultCode=NA)
  if(!'away.periods.resultCode'%in%names(temp)) temp <- temp %>% mutate(away.periods.resultCode=NA)
  temp %>%
    select(match.id='matchId',
           home.id,home.name,home.code,
           away.id,away.name,away.code,
           period='home.periods.period',
           home.goals=if_else(cumulative,'home.periods.goalsCumulative','home.periods.goals'),
           home.behinds=if_else(cumulative,'home.periods.behindsCumulative','home.periods.behinds'),
           home.points=if_else(cumulative,'home.periods.pointsCumulative','home.periods.points'),
           home.result=if_else(cumulative,'home.result.cumulative','home.periods.resultCode'),
           home.margin=if_else(cumulative,'home.periods.marginCumulative','home.periods.margin'),
           away.goals=if_else(cumulative,'away.periods.goalsCumulative','away.periods.goals'),
           away.behinds=if_else(cumulative,'away.periods.behindsCumulative','away.periods.behinds'),
           away.points=if_else(cumulative,'away.periods.pointsCumulative','away.periods.points'),
           away.result=if_else(cumulative,'away.result.cumulative','away.periods.resultCode'),
           away.margin=if_else(cumulative,'away.periods.marginCumulative','away.periods.margin'),
           winning.squad.id = if_else(cumulative,'winning.squad.cumulative','winning.squad.period'),
           cumulative)
}

#'Match Transactions
#'
#'Get the list of transactions for a match. Returns observed & not yet observed metrics.
#'
#'@import purrr
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of transactions for a match. 
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier for a match.
#'    \item \code{trx.id} A unique numerical identifier for a given transaction, used for ordering chronologically.
#'    \item \code{stat.code} The statistic code for a given transaction.
#'    \item \code{stat.desc} A short description of the statistic code for a transaction.  
#'    \item \code{period} The period of the transaction.
#'    \item \code{period.secs} The elapsed time within the period of a transaction. 
#'    \item \code{score.home} The score of the home squad.
#'    \item \code{score.away} The score of the away squad.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{squad.id} A unique numerical identifier for the squad.
#'    \item \code{person.fullname} The fullname of the player assigned to the transaction (if applicable).
#'    \item \code{person.displayName} The display name of the player assigned to the transaction (if applicable).
#'    \item \code{person.id} A unique numerical identifier for the player assigned to the transaction (if applicable).
#'    \item \code{pressure.squad.name} The name of the squad the pressure information is assigned to.
#'    \item \code{pressure.squad.id} A unique numerical identifier for the squad the pressure information is assigned to. 
#'    \item \code{pressure.squad.code} A short code to represent the squad the pressure information is assigned to.
#'    \item \code{pressure.name} The name of the type of pressure applied (ie. Set Position). 
#'    \item \code{pressure.code} A short code to represent the type of pressure applied.
#'    \item \code{pressure.points} The points value of the type of pressure applied.
#'    \item \code{pressure.fullname1} The fullname of the first pressure player.
#'    \item \code{pressure.displayname1} The display name of the first pressure player.
#'    \item \code{pressure.personid1} A unique numerical identifier for the first pressure player.
#'    \item \code{pressure.role1} The role number of the first pressure player (1).
#'    \item \code{pressure.fullname2} The fullname of the second pressure player.
#'    \item \code{pressure.displayname2} The display name of the second pressure player. 
#'    \item \code{pressure.personid2} A unique numerical identifier for the second pressure player.
#'    \item \code{pressure.role2} The role number of the second pressure player (2).
#'    \item \code{zone.physical} The zone in which the transaction takes place, relative to the physical ground.
#'    \item \code{zone.logical} The zone in which the transaction takes place, relative to the squad in possession.
#'    \item \code{location.x} The x coordinate of the transaction.
#'    \item \code{location.y} the y coordinate of the transaction.
#'    \item \code{location.x.std} The x coordinate of the transaction transformed to a standard ground dimension (160x141).
#'    \item \code{location.y.std} The y coordinate of the transaction transformed to a standard ground dimension (160x141).
#'    \item \code{location.rotated.x} The x coordinate of the transaction rotated to give all squads attacking left-to-right.
#'    \item \code{location.rotated.y} The y coordinate of the transaction rotated to give all squads attacking left-to-right.
#'    \item \code{location.rotated.x.std} The x coordinate of the transaction transformed to a standard ground dimension (160x141) & rotated to give all squads attacking left-to-right.
#'    \item \code{location.rotated.y.std} The y coordinate of the transaction transformed to a standard ground dimension (160x141) & rotated to give all squads attacking left-to-right.
#'    \item \code{kicking.foot} On kicking transactions, the foot of the kicking player.
#'    \item \code{kicking.intent} On kicking transactions, the intent of the kicking player.
#'    \item \code{kicking.distance} On kicking transactions, a description of the kicks distance.
#'    \item \code{kicking.direction} On kicking transactions, a description of the kicks direction.
#'    \item \code{inside50.direction} On inside 50 transactions, a description of the kicks direction.
#'    \item \code{inside50.intent} On inside 50 transactions, the intent of the kicking player.
#'    \item \code{shot.angle} A text description of the angle of the shot.
#'    \item \code{shot.distance} A text description of the distance of the shot.
#'    \item \code{shot.result} The result of the shot on goal (Does not include Goals).
#'    \item \code{shot.source} The source from which the shot on goal resulted (ie. General Play).
#'    \item \code{shot.type} The type of shot attempted (ie. General Play Snap).
#'    \item \code{freekick.context} On free kick transactions, the broad context from which the free kick was awarded.
#'    \item \code{freekick.reason} On free kick transactions, the specific reason the free kick was awarded.
#'    \item \code{kickin.direction} On kick in transactions, a text description of the direction taken from the kick in.
#'}
#'@examples
#'getMatchTransactions(216085122)
#'@export
getMatchTransactions <- function(matchId,...){
  
  # Hit API for response
  rawResponse <- cdAPIresponse(endpoint = paste('matches',matchId,"transactions",sep = '/'), ...) 
  
  if(is.null(rawResponse)){
    
    return(rawResponse)
    
  } else {
    
    # Convert response to flat list
    listResponse <- fromJSON(content(rawResponse,'text'),flatten=TRUE)
    
    # Handle if successful response but no events happened yet (second element of list empty)
    if(is_empty(listResponse[[1]])) {
      returnData        <- data.frame(matrix(ncol = length(getMatchTransactionsWhitelist), nrow = 0))
      names(returnData) <- getMatchTransactionsWhitelist
      message(paste0("\nWarning\n--> 0 rows of data in response.")) 
      return(returnData)
      
      # Normal response, play on    
    } else {
      
      # Convert list into DF
      returnData <- data.frame(listResponse)
      
      # strip 'transactions.' prefix
      names(returnData) <- gsub("^transactions\\.", "", names(returnData))
      
      # Get an index for each row attributed to a trx (for joining pressure info on only the first row)
      returnData$trx_n <- ave(seq_along(returnData$id), returnData$id, FUN = seq_along)
      
      #################
      # PRESSURE INFO #
      #################
      
      # Split out & handle pressure player info, join back to returnData
      if("pressure.players" %in% names(returnData)){
        
        # unnest & split out the pressure cols
        pressureData <- returnData[,c("id","pressure.players")] %>%  # need to retain 'id' here for join later
          tidyr::unnest_wider(., pressure.players, names_sep = "_")
        
        # Filter out all of rows that dont have pressure info (below lapply() wont work otherwise)
        pressureData = pressureData[!is.na(pressureData[[2]]),]
        
        # delimit each of the pressure cols (x==2 coniditional so that 'id' col only comes in once)
        pressureData <- lapply(2:5, function(x) {
          if(x==2) cbind(pressureData[, "id"],do.call(rbind, as.list(pressureData[[x]])))
          else cbind(do.call(rbind, as.list(pressureData[[x]])));
        })
        
        # Convert to DF
        pressureData = data.frame(pressureData)
        
        # This if/else will handle if there are *ONLY* 1-player pressure stats in the response OR if there are both 1&2 pressure stats, and handle accordingly
        if(dim(pressureData)[2]==5){
          names(pressureData)[2:5] <- getMatchTransactionsPressureCols1Player                                                                               # Rename with first pressure player colnames
          pressureData[getMatchTransactionsPressureCols2Player] <- lapply(getMatchTransactionsPressureCols2Player, function(x) rep(NA, nrow(pressureData))) # Add in second pressure player cols as NA
          pressureData$trx_n <- 1                                                                                                                           # Add in a trx_n column that = 1 so pressure info will only join to the first row of the given trx (if there are multiple rows for a single trx) // returnData has been set with a count for each row of each trx to join to
        } else {
          names(pressureData)[2:9] <- getMatchTransactionsPressureCols                            # 2nd pressure player stats exist so rename with full pressureCols vector
          singlePressureTrx <- pressureData$pressure.personid1 == pressureData$pressure.personid2 # Identifying rows where pressure.personid1 = pressure.personid2 (therefore only single pressure player TRX)
          pressureData[singlePressureTrx, getMatchTransactionsPressureCols2Player] <- NA          # Make second pressure player cols NA when only a single pressure player trx
          pressureData$trx_n <- 1                                                                 # Add in a trx_n column that = 1 so pressure info will only join to the first row of the given trx (if there are multiple rows for a single trx) // returnData has been set with a count for each row of each trx to join to
        }
        
        ########
        
        # Join the original data back on to the pressure info
        returnData <- left_join(returnData,pressureData, by = c("id","trx_n")) %>% select(-"pressure.players",-"trx_n")
        
        # Turn pressure data into correct types
        returnData[getMatchTransactionsPressureCols[1:4]] <- lapply(returnData[getMatchTransactionsPressureCols[1:4]], as.character)
        returnData[getMatchTransactionsPressureCols[5:8]] <- lapply(returnData[getMatchTransactionsPressureCols[5:8]], as.integer)
        
      }
      
      #################
      
      # get vector of missing cols between whitelist and response
      missing <- setdiff(getMatchTransactionsWhitelist,names(returnData))
      
      # Add on any of the missing columns in the response 
      returnData[missing] <- lapply(missing, function(x) rep(NA, nrow(returnData)))
      
      # Select exposed fields (getMatchTransactionsExposedFields) & rename columns
      returnData        <- returnData[, getMatchTransactionsExposedFields]
      names(returnData) <- names(getMatchTransactionsExposedFields)
      
      return(returnData)
    }
  }
}

#'Match Entries
#'
#'Get a list of Inside 50 entries for a match.
#'@param matchId A unique numerical identifier of a match.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of inside 50 entries for a match, with one row per entry. NULL if the match is yet to start.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{entry.trx.id} The transaction ID of the entry, used for ordering chronologically.
#'    \item \code{entry.period} The period of the entry.
#'    \item \code{entry.period.secs} The elapsed time within the period of the entry.
#'    \item \code{entry.player.id} A unique numerical identifier of the player responsible for the entry.
#'    \item \code{entry.player.fullname} The fullname of the player responsible for the entry. 
#'    \item \code{entry.player.display.name} The display name of the player responsible for the entry.
#'    \item \code{entry.squad.id} A numerical identifier of the squad player responsible for the entry belongs to. 
#'    \item \code{entry.squad.name} The name of the squad the player responsible for the entry belongs to. 
#'    \item \code{entry.squad.code} A short code to represent the squad the player responsible for the entry belongs to. 
#'    \item \code{entry.type} The type of inside 50 entry.
#'    \item \code{entry.source.name} The game situation relative to the origin of a team's possession that results in an entry.
#'    \item \code{entry.source.type} Inside 50 entries where direct indicates the first chain after the specified entry.source.name 
#'    
#'    For centre bounce and midfield stoppage \code{entry.source.name}, direct indicates the entry was in the clearance chain \cr
#'    
#'    For repeat \code{entry.source.name}, direct indicates the entry was on the first turnover chain after an opposition rebound 50 \cr
#'    
#'    For transition \code{entry.source.name}, direct indicates the entry was in the same chain as the rebound 50
#'    \item \code{entry.kick.is.ground} For inside 50 entries that are kicks, was the entry from a ground kick (true/false).
#'    \item \code{entry.kick.foot} For inside 50 entries that are kicks, which foot did the kicking player use.
#'    \item \code{entry.kick.intent} For inside 50 entries that are kicks, the intent of the kicker. 
#'    \item \code{entry.kick.distance} For inside 50 entries that are kicks, the distance of the kick.
#'    \item \code{entry.kick.direction} For inside 50 entries that are kicks, the direction of the kick
#'    \item \code{entry.kick.launch.distance.to.goal} For inside 50 entries that are kicks, the straight line distance to goal from the launch point of the kick.
#'    \item \code{entry.kick.result.distance.to.goal} For inside 50 entries that are kicks, the straight line distance to goal from the result point of the kick.
#'    \item \code{entry.kick.pressure.name} For inside 50 entries that are kicks, the name of the type of pressure applied to the kicker.
#'    \item \code{entry.kick.pressure.code} For inside 50 entries that are kicks, a short code to describe the type of pressure applied to the kicker.
#'    \item \code{entry.kick.pressure.points} For inside 50 entries that are kicks, the number of points associated with the pressure type applied to the kicker.
#'    \item \code{entry.kick.launch.location.x} The x coordinate of the inside 50 launch location.
#'    \item \code{entry.kick.launch.location.y} The y coordinate of the inside 50 launch location.
#'    \item \code{entry.kick.launch.location.x.std} The x coordinate of the inside 50 launch location transformed to a standard ground dimension (160x141).
#'    \item \code{entry.kick.launch.location.y.std} The y coordinate of the inside 50 launch location transformed to a standard ground dimension (160x141).
#'    \item \code{entry.kick.launch.location.rotated.x} The x coordinate of the inside 50 launch location rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.launch.location.rotated.y} The y coordinate of the inside 50 launch location rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.launch.location.rotated.x.std} The x coordinate of the inside 50 launch location transformed to a standard ground dimension (160x141) & rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.launch.location.rotated.y.std} The x coordinate of the inside 50 launch location transformed to a standard ground dimension (160x141) & rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.result.location.x} The x coordinate of the inside 50 result location. 
#'    \item \code{entry.kick.result.location.y} The y coordinate of the inside 50 result location. 
#'    \item \code{entry.kick.result.location.x.std} The x coordinate of the inside 50 result location transformed to a standard ground dimension (160x141).
#'    \item \code{entry.kick.result.location.y.std} The y coordinate of the inside 50 result location transformed to a standard ground dimension (160x141).
#'    \item \code{entry.kick.result.location.rotated.x} The x coordinate of the inside 50 result location rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.result.location.rotated.y} The y coordinate of the inside 50 result location rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.result.location.rotated.x.std} The x coordinate of the inside 50 result location transformed to a standard ground dimension (160x141) & rotated to give all squads attacking left-to-right.
#'    \item \code{entry.kick.result.location.rotated.y.std} The y coordinate of the inside 50 result location transformed to a standard ground dimension (160x141) & rotated to give all squads attacking left-to-right.
#'}
#'@examples
#'getEntries(216085122)
#'@export
getEntries <- function(matchId,verbose=F,...){
  
  rawResponse <- cdAPIresponse(matchId,paste('matches',matchId,'entries',sep='/'),...)
  
  if(is.null(rawResponse)){
    return(rawResponse)
  } else {
    # Convert response to flat list
    listResponse <- fromJSON(content(rawResponse,'text'),flatten=TRUE)
    
    # Handle if successful response but no events happened yet (second element of list empty)
    if(is_empty(listResponse[[2]])) {
      returnData        <- data.frame(matrix(ncol = length(getEntriesWhitelist), nrow = 0))
      names(returnData) <- getEntriesWhitelist
      message(paste0("\nWarning\n--> 0 rows of data in response.")) 
      return(returnData)
    } else {
      # Convert list into DF
      returnData <- data.frame(listResponse)
      
      # Get vector of the missing fields (IF ANY) in the call info
      missing <- setdiff(getEntriesWhitelist,names(returnData))
      
      # Add on any of the missing columns in the response 
      returnData[missing] <- lapply(missing, function(x) rep(NA, nrow(returnData)))
    }
    
    # Select exposed fields (getEntriesExposedFields) & rename columns
    returnData        <- returnData[, getEntriesExposedFields]
    names(returnData) <- names(getEntriesExposedFields)
    
    return(returnData)
  }
} 

#'Match Squad Stats (POST Endpoint)
#'
#'Get squad stats for a match via a payload to the POST endpoint. 
#'@param matchId A unique numerical identifier of a match.
#'@param payload A nested list containing the parcels of data to be returned by the API. See: \code{createPayload()} as a method of simplifying this step.
#'@param info A logical (\code{TRUE/FALSE}) to include the payload information alongside the data for each payload. Defaults to \code{FALSE}
#'@param verbose  A logical (\code{TRUE/FALSE}) indicating whether to enable verbose messaging to the console. When set to \code{TRUE}, the function will print additional information and progress messages to the console to provide a more detailed view of its execution. Defaults to \code{FALSE} for a quieter output.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of metrics supplied by the payload for each player in a match.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{stat.code} The metric code (ALL_CAPS format).
#'    \item \code{stat.name} The metric name (singular).
#'    \item \code{stat.plural} The metric name (plural).
#'    \item \code{value} The numeric metric value with no formatting applied.
#'    \item \code{display} The formatted metric value as a text string.
#'    \item \code{id} A unique identifier string able to be supplied by the user for each list in the payload. Defaults to numerical index starting at 0. 
#'    
#'    \item \code{info.metric.codes} (when \code{info = TRUE}) The metric code(s) supplied to the specific list in the payload for that row of data.
#'    \item \code{info.periods} (when \code{info = TRUE}) The period(s) supplied to the specific list in the payload for that row of data.
#'    \item \code{info.zones} (when \code{info = TRUE}) The zone(s) supplied to the specific list in the payload for that row of data.
#'    \item \code{info.team} (when \code{info = TRUE}) The team supplied to the specific list in the payload for that row of data.
#'    \item \code{info.context} (when \code{info = TRUE}) The match context supplied to the specific list in the payload for that row of data.
#'}
#'@examples
#'getSquadStatsPOST(matchId = 120390401, payload = squadPayload, info = T, verbose = T)
#'@export
getSquadStatsPOST <- function(matchId, payload, info = FALSE, verbose = F, ...){
  
  if(sub("MetricRequests", "", names(payload)) == "squad"){
    fieldsToCheck <- c("metricCodes", "team", "periods", "zones")
  } else {
    message("Incorrect payload passed to function\n--> Have you provided a PLAYER payload to the SQUAD function?")
    return()
  } 
  
  # Using cdAPIPOSTresponse function to hit/retrieve response from POST API 
  rawResponse <- cdAPIPOSTresponse(matchId = matchId, endpoint = "squad", payload = payload, ...)
  
  if(is.null(rawResponse)){
    return(rawResponse)
    
  } else {
    
    if(verbose){
      payloadDefaults(payload)                                                                  # Check if payload full, communicate defaults
      message(paste0("\nSuccess [Status: ",rawResponse$status,"]\n--> POST request successful.")) # Communicate success
    }
    
    # Formatting response - response as list
    listResponse <- fromJSON(content(rawResponse,'text'),flatten=TRUE)
    
    # Extract data out of listResponse
    returnData <- listResponse[[1]] %>% 
      tidyr::unnest("squads", names_sep = "_") %>%  
      filter(!(row_number() %in% which(sapply(.$squads_statistics,class)=="list"))) %>% 
      tidyr::unnest("squads_statistics", names_sep = "_")
    
    if(nrow(returnData) == 0) {
      if(verbose) message(paste0("\nWarning\n--> 0 rows of data for the payload supplied.")) 
    } else {
      returnData <- returnData %>% 
        select("match.id"="matchId", 
               "squad.name"="squads_name",
               "squad.code"="squads_code",
               "squad.id"="squads_id",
               "stat.code"="squads_statistics_code",
               "stat.name"="squads_statistics_name",
               "stat.plural"="squads_statistics_namePlural",
               "value"="squads_statistics_value", 
               "display"="squads_statistics_valueDisplay",
               id)
    }
    
    # Include the information from the payload call in the output? (info = T/F)
    if(info){
      
      # Get vector of the missing fields in the call info
      missing <- setdiff(c("metricCodes","periods","team","zones","context"),names(listResponse[[2]][-which(names(listResponse[[2]]) == "id")]))
      
      # Extract info
      callInfo <- listResponse[[2]] %>%                              # [[2]] gives the player/squad metric requests included in the payload
        mutate_if(is.list, simplify_all) %>%                         # Flatten out (necessary)
        mutate(!!!setNames(rep(NA, length(missing)), missing)) %>%   # Create cols for any of the missing params
        mutate(metricCodes = ifelse(is.na(metricCodes) | metricCodes == "NULL", "All Available" ,gsub('["c()]', '', metricCodes)) , 
               periods     = ifelse(is.na(periods)     | periods == "NULL", "Match",gsub('["c()]', '', periods)) , 
               team        = ifelse(is.na(team)        | team  == "NULL", "Both" ,gsub('["c()]', '', team)),
               zones       = ifelse(is.na(zones)       | zones == "NULL", "All"  ,gsub('["c()]', '', zones)),
               context     = ifelse(is.na(context)     | zones == "NULL", "For"  ,gsub('["c()]', '', context))) %>% 
        dplyr::rename(any_of(
          c("info.metric.codes"="metricCodes",
            "info.periods"="periods" , 
            "info.team"="team",
            "info.context"="context",
            "info.zones"="zones"))) %>% 
        select(info.metric.codes, info.team, info.periods, info.zones, info.context, id)
      
      returnData <- returnData %>% 
        dplyr::left_join(.,callInfo,"id") %>% 
        relocate(id, .after = last_col())
      
    } else {
      # Remove the joinId if info not required
      returnData <- returnData %>%
        relocate(id, .after = last_col())
    }
    return(returnData)
  }
}

#'Match Player Stats (POST Endpoint)
#'
#'Get player stats for a match via a payload to the POST endpoint. 
#'@param matchId A unique numerical identifier of a match.
#'@param payload A nested list containing the parcels of data to be returned by the API. See: \code{createPayload()} as a method of simplifying this step.
#'@param info A logical (\code{TRUE/FALSE}) to include the payload information alongside the data for each payload. Defaults to \code{FALSE}
#'@param verbose  A logical (\code{TRUE/FALSE}) indicating whether to enable verbose messaging to the console. When set to \code{TRUE}, the function will print additional information and progress messages to the console to provide a more detailed view of its execution. Defaults to \code{FALSE} for a quieter output.
#'@param ... Arguments to be passed to internal functions, such as \code{envir} or \code{version}.
#'@return A data frame with a list of metrics supplied by the payload for each player in a match.
#'\itemize{
#'    \item \code{match.id} A unique numerical identifier of a match.
#'    \item \code{squad.name} The name of the squad.
#'    \item \code{squad.code} A short code to represent the squad.
#'    \item \code{squad.id} A unique numerical identifier of the squad.
#'    \item \code{player.name} The full name of the player.
#'    \item \code{player.display} The display name of the player, represented as first initial and surname.
#'    \item \code{player.id} A unique numerical identifier of the player.
#'    \item \code{stat.code} The metric code (ALL_CAPS format).
#'    \item \code{stat.name} The metric name (singular).
#'    \item \code{stat.plural} The metric name (plural).
#'    \item \code{value} The numeric metric value with no formatting applied.
#'    \item \code{display} The formatted metric value as a text string.
#'    \item \code{id} A unique identifier string able to be supplied by the user for each list in the payload. Defaults to numerical index starting at 0. 
#'    \item \code{info.metric.codes} (when \code{info = TRUE}) The metric code(s) supplied to the specific list in the payload for that row of data.
#'    \item \code{info.periods} (when \code{info = TRUE}) The period(s) supplied to the specific list in the payload for that row of data.
#'    \item \code{info.zones} (when \code{info = TRUE}) The zone(s) supplied to the specific list in the payload for that row of data.
#'    \item \code{info.team} (when \code{info = TRUE}) The team supplied to the specific list in the payload for that row of data.
#'    \item \code{info.context} (when \code{info = TRUE}) The match context supplied to the specific list in the payload for that row of data.
#'}
#'@examples
#'getSquadStatsPOST(matchId = 120390401, payload = squadPayload, info = T, verbose = T)
#'@export
getPlayerStatsPOST <- function(matchId, payload, info = FALSE, verbose = F, ...){
  
  if(sub("MetricRequests", "", names(payload)) == "player"){
    fieldsToCheck <- c("metricCodes", "team", "periods", "zones")
  } else {
    message("Incorrect payload passed to function\n--> Have you provided a SQUAD payload to the PLAYER function?")
    return()
  } 
  
  # Using cdAPIPOSTresponse function to hit/retrieve response from POST API 
  rawResponse <- cdAPIPOSTresponse(matchId = matchId, endpoint = "player", payload = payload, ...)
  
  if(is.null(rawResponse)){
    return(rawResponse)
    
  } else {  
    
    if(verbose){
      payloadDefaults(payload)                                                                  # Check if payload full, communicate defaults
      message(paste0("\nSuccess [Status: ",rawResponse$status,"]\n--> POST request successful.")) # Communicate success
    }
    
    # Formatting response - response as list
    listResponse <- fromJSON(content(rawResponse,'text'),flatten=TRUE)
    
    # unnest Down to players
    returnData <- listResponse[[1]] %>% 
      tidyr::unnest("squads", names_sep = "_") %>%  
      tidyr::unnest("squads_players")
    
    # Get vector of indexes of type list in statistics
    listRows <- which(sapply(returnData$statistics,class)=="list")
    
    # Extract data out of listResponse
    returnData <- returnData %>%
      filter(!(row_number() %in% listRows)) %>% # If any rows are of class list - remove them before unnesting below (will generate error)
      tidyr::unnest("statistics", names_sep = "_")
    
    if(nrow(returnData) == 0) {
      if(verbose) message(paste0("\nWarning\n--> 0 rows of data for the payload supplied.")) 
    } else {
      returnData <- returnData %>% 
        select("match.id"="matchId", 
               "squad.name"="squads_name",
               "squad.code"="squads_code",
               "squad.id"="squads_id",
               "player.name"="fullname", 
               "player.display"="displayName",
               "player.id"="personId",
               "stat.code"="statistics_code",
               "stat.name"="statistics_name",
               "stat.plural"="statistics_namePlural",
               "value"="statistics_value", 
               "display"="statistics_valueDisplay",
               id)
    }
    
    # Include the information from the payload call in the output? (info = T/F)
    if(info){
      
      # Get vector of the missing fields in the call info
      missing <- setdiff(c("metricCodes","periods","team","zones"),names(listResponse[[2]][-which(names(listResponse[[2]]) == "id")]))
      
      # Extract info
      callInfo <- listResponse[[2]] %>%                              # [[2]] gives the player/squad metric requests included in the payload
        mutate_if(is.list, simplify_all) %>%                         # Flatten out (necessary)
        mutate(!!!setNames(rep(NA, length(missing)), missing)) %>%   # Create cols for any of the missing params
        mutate(metricCodes = ifelse(is.na(metricCodes) | metricCodes == "NULL", "All Available" ,gsub('["c()]', '', metricCodes)) , 
               periods     = ifelse(is.na(periods)     | periods == "NULL", "Match",gsub('["c()]', '', periods)) , 
               team        = ifelse(is.na(team)        | team  == "NULL", "Both" ,gsub('["c()]', '', team)),
               zones       = ifelse(is.na(zones)       | zones == "NULL", "All"  ,gsub('["c()]', '', zones))) %>% 
        dplyr::rename(any_of(
          c("info.metric.codes"="metricCodes",
            "info.periods"="periods" , 
            "info.team"="team",
            "info.context"="context",
            "info.zones"="zones"))) %>% 
        select(id, info.metric.codes, info.team, info.periods, info.zones)
      
      returnData <- returnData %>% 
        left_join(.,callInfo,"id") %>% 
        relocate(id, .after = last_col())
      
    } else {
      # Remove the joinId if info not required
      returnData <- returnData %>%
        relocate(id, .after = last_col())
    }
    return(returnData)
  } 
}

